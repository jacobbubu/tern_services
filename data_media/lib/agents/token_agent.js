// Generated by CoffeeScript 1.3.3
/*
# Token Model
#   
#   Get Access Token's info then cache it in local db
*/

var BrokersHelper, Cache, Checker, DB, Err, Log, TokenCacheTableKey, Utils, ZMQSender, configInit, coreClass, internals, tokenCacheModel, _TokenModel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  _this = this;

Log = require('tern.logger');

Err = require('tern.exceptions');

Checker = require('tern.param_checker');

DB = require('tern.database');

Cache = require('tern.cache');

Utils = require('tern.utils');

BrokersHelper = require('tern.central_config').BrokersHelper;

ZMQSender = require('tern.zmq_helper').zmq_sender;

/*
# Redis Database
# TokenCacheTable:
#   type: HASH
#   key:  token_cache/accessToken#
*/


TokenCacheTableKey = function(accessToken) {
  return Utils.pathJoin("token_cache", accessToken);
};

coreClass = (function() {
  var _instance;

  function coreClass() {}

  _instance = void 0;

  coreClass.get = function() {
    return _instance != null ? _instance : _instance = new _TokenModel;
  };

  return coreClass;

})();

_TokenModel = (function() {

  function _TokenModel() {
    this.getInfo = __bind(this.getInfo, this);
    this.db = DB.getDB('tokenCacheDB');
    this.authSender = null;
    this.cache = new Cache("tokens", {
      size: 10,
      expiry: 60000
    });
  }

  _TokenModel.prototype.getInfo = function(accessToken, next) {
    var key, message, tokenObject,
      _this = this;
    if (accessToken == null) {
      throw new ArgumentNullException("'accessToken' required.");
    }
    tokenObject = this.cache.get(accessToken);
    if (tokenObject != null) {
      return next(null, tokenObject);
    }
    message = {
      method: "tokenAuth",
      data: {
        access_token: accessToken
      }
    };
    key = TokenCacheTableKey(accessToken);
    return this.db.hgetall(key, function(err, tokenObject) {
      if (err != null) {
        return next(err);
      }
      if (tokenObject != null) {
        tokenObject.scope = tokenObject.scope.split(/\s+/);
        _this.cache.set(accessToken, tokenObject);
        return next(null, tokenObject);
      }
      return _this.authSender.send(message, function(err, response) {
        var result;
        if (err != null) {
          return next(err);
        }
        if (response.response.status === 200) {
          result = response.response.result;
          tokenObject = {
            access_token: result.access_token,
            user_id: result.user_id,
            scope: result.scope,
            data_zone: result.data_zone,
            expire_at: +(new Date) + result.expires_in * 1000
          };
          return _this.db.multi().hmset(key, tokenObject).expire(key, result.expires_in).exec(function(err, replies) {
            if (err != null) {
              return next(err);
            }
            tokenObject.scope = result.scope.split(/\s+/);
            _this.cache.set(accessToken, tokenObject);
            return next(null, tokenObject);
          });
        } else {
          err = Err.ResourceDoesNotExistException("Access Token(" + accessToken + ") does not exist.");
          return next(err);
        }
      });
    });
  };

  return _TokenModel;

})();

internals = {
  configObj: null,
  config: null
};

internals.configObj = BrokersHelper.getConfig('centralAuth/zmq/connect');

if (internals.configObj != null) {
  internals.config = internals.configObj.value;
  internals.configObj.on('changed', function(oldValue, newValue) {
    console.log("CentralAuth ZMQ config changed (host: " + newValue.host + " port: " + newValue.port + ")");
    internals.config = newValue;
    return configInit();
  });
} else {
  throw new Error('Config for CentralAuth ZMQ required');
}

configInit = function() {
  var authSender, config, tokenCacheModel;
  config = internals.config;
  authSender = new ZMQSender("tcp://" + config.host + ":" + config.port);
  tokenCacheModel = coreClass.get();
  if (tokenCacheModel.authSender != null) {
    tokenCacheModel.authSender.close();
  }
  return tokenCacheModel.authSender = authSender;
};

configInit();

/*
# Module Exports
*/


tokenCacheModel = coreClass.get();

module.exports.getInfo = function(accessToken, next) {
  return tokenCacheModel.getInfo(accessToken, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};
