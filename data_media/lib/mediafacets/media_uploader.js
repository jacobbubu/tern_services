// Generated by CoffeeScript 1.3.3
var Assert, DeviceIds, Err, Inspect, LengthPattern, Log, MaxEntitySize, MaxInstanceSize, MediaFile, MediaIdPattern, MediaType, MemoAgent, Utils, headersParse, mediaUpload, send200ok, send308Range, uploadSucceed;

Log = require('tern.logger');

Utils = require('tern.utils');

MediaType = require('tern.media_type');

Err = require('./media_error');

Assert = require('assert');

Inspect = require('util').inspect;

MediaFile = require('../models/media_file_mod');

MemoAgent = require('../agents/memo_agent');

DeviceIds = require('tern.device_ids');

MediaIdPattern = /^([^\s]{1,24}):[+-]?(\d{1,18})$/;

LengthPattern = /^\d{1,18}$/;

MaxInstanceSize = 150 * 1024 * 1024;

MaxEntitySize = 4 * 1024 * 1024;

headersParse = function(req, res) {
  var byteRangeResp, contentLength, contentType, firstBytePos, instanceLength, instanceMD5, lastBytePos, rangeValue, requestObj, unit, _ref, _ref1;
  requestObj = null;
  contentLength = req.headers['content-length'];
  if (contentLength == null) {
    if (contentLength == null) {
      Err.sendError(res, Err.CODES.CONTENT_LENGTH_REQUIRED);
    }
    return requestObj;
  }
  contentLength = parseInt(contentLength, 10);
  if (isNaN(contentLength) || contentLength < 0 || contentLength > MaxEntitySize) {
    Err.sendError(res, Err.CODES.CONTENT_LENGTH_IS_OOR, 0, Utils.byteSizePresent(MaxEntitySize));
    return requestObj;
  }
  contentType = req.headers['content-type'];
  if (contentType == null) {
    Err.sendError(res, Err.CODES.CONTENT_TYPE_REQUIRED);
    return requestObj;
  }
  contentType = contentType.toLowerCase();
  if (!MediaType.isSupported(contentType)) {
    Err.sendError(res, Err.CODES.CONTENT_TYPE_UNSUPPORTED);
    return requestObj;
  }
  rangeValue = req.headers['content-range'];
  if (rangeValue == null) {
    Err.sendError(res, Err.CODES.CONTENT_RANGE_REQUIRED);
    return requestObj;
  }
  _ref = rangeValue.match(/[a-z0-9\-_\*]+/gi), unit = _ref[0], byteRangeResp = _ref[1], instanceLength = _ref[2];
  if (unit.toLowerCase() !== 'bytes') {
    Err.sendError(res, Err.CODES.CONTENT_RANGE_UNSUPPORTED_UNIT);
    return requestObj;
  }
  if (!/^\d+$/.test(instanceLength)) {
    Err.sendError(res, Err.CODES.CONTENT_RANGE_INVALID_INSTANCE_LENGTH);
    return requestObj;
  }
  instanceLength = parseInt(instanceLength, 10);
  if (isNaN(instanceLength)) {
    Log.error("parsesInt error: instance length of content-range ('" + instanceLength + "') .");
    Err.sendError(res, Err.CODES.CONTENT_RANGE_INVALID_INSTANCE_LENGTH);
    return requestObj;
  } else {
    if (!((0 < instanceLength && instanceLength < MaxInstanceSize))) {
      Err.sendError(res, Err.CODES.CONTENT_RANGE_INSTANCE_LENGTH_IS_OOR, 0, Utils.byteSizePresent(MaxInstanceSize));
      return requestObj;
    }
  }
  _ref1 = byteRangeResp.split('-'), firstBytePos = _ref1[0], lastBytePos = _ref1[1];
  firstBytePos = isNaN(parseInt(firstBytePos, 10)) ? 0 : parseInt(firstBytePos, 10);
  lastBytePos = isNaN(parseInt(lastBytePos, 10)) ? 0 : parseInt(lastBytePos, 10);
  if (contentLength > instanceLength) {
    Err.sendError(res, Err.CODES.CONTENT_LENGTH_IS_GREATER_THAN_INSTANCE_LENGTH);
    return requestObj;
  }
  instanceMD5 = req.headers['x-instance-md5'];
  if (instanceMD5 != null) {
    try {
      instanceMD5 = Utils.base64ToHex(instanceMD5);
    } catch (e) {
      Err.sendError(res, Err.CODES.BAD_MD5);
      return requestObj;
    }
  } else {
    Err.sendError(res, Err.CODES.BAD_MD5);
    return requestObj;
  }
  return requestObj = {
    instanceLength: instanceLength,
    instanceMD5: instanceMD5,
    firstBytePos: firstBytePos,
    lastBytePos: lastBytePos,
    contentLength: contentLength,
    contentType: contentType
  };
};

send308Range = function(res, length) {
  var lastPos;
  lastPos = length <= 0 ? 0 : length - 1;
  res.header('Range', "0-" + lastPos);
  return res.send(308);
};

send200ok = function(res) {
  res.header('Content-Length', 0);
  res.statusCode = 200;
  return res.end();
};

uploadSucceed = function(fileInfo, req, res) {
  send200ok(res);
  return process.nextTick(function() {
    var data_zone, memo;
    data_zone = req._tern.user_data_zone;
    memo = {
      mid: fileInfo.media_id,
      user_id: fileInfo.user_id,
      device_id: DeviceIds.media_server,
      updated_at: Utils.UTCString(),
      media_meta: {
        content_type: fileInfo.contentType,
        content_length: fileInfo.instanceLength,
        md5: fileInfo.instanceMD5,
        uri: req.headers['host'] + req.url,
        media_zone: req._tern.media_zone
      }
    };
    return MemoAgent.mediaWriteback(data_zone, memo, function(err) {
      var errMessage;
      if (err != null) {
        errMessage = ("Error mediaWriteback: " + (err.toString()) + "\r\n" + err.stack + "\r\nData Zone: " + data_zone + "\r\nMemo: ") + Inspect(memo);
        return Log.error(errMessage);
      }
    });
  });
};

/*
  Media upload middleware
*/


mediaUpload = function(req, res, next) {
  var fileInfo, invalidParams, mediaStore, requestParams, uploadResult;
  Assert.equal(req.method, 'PUT');
  Assert.ok(req._tern);
  Assert.ok(req._tern.user_id);
  Assert.ok(req._tern.media_id);
  req.pause();
  requestParams = headersParse(req, res);
  if (requestParams != null) {
    mediaStore = null;
    uploadResult = null;
    fileInfo = requestParams;
    fileInfo.user_id = req._tern.user_id;
    fileInfo.media_id = req._tern.media_id;
    invalidParams = fileInfo.firstBytePos === fileInfo.lastBytePos;
    invalidParams = invalidParams || fileInfo.contentLength === 0;
    invalidParams = invalidParams || fileInfo.lastBytePos - fileInfo.firstBytePos + 1 !== fileInfo.contentLength;
    if (invalidParams) {
      return MediaFile.stat(req._tern.media_id, function(err, stats) {
        if (err != null) {
          return next(err);
        }
        return send308Range(res, stats.currentLength);
      });
    } else {
      return MediaFile.startUpload(fileInfo, function(err, gridStore) {
        var chunkUpload;
        if (err != null) {
          return next(err);
        }
        mediaStore = gridStore;
        if (mediaStore.position === fileInfo.instanceLength) {
          MediaFile.closeUpload(fileInfo, mediaStore, function(err, result) {
            if (err != null) {
              return next(err);
            }
            uploadResult = result;
            return send200ok(res);
          });
          return;
        }
        if (fileInfo.firstBytePos !== mediaStore.position || fileInfo.lastBytePos + 1 > fileInfo.instanceLength) {
          MediaFile.closeUpload(fileInfo, mediaStore, function(err, result) {
            if (err != null) {
              return next(err);
            }
            uploadResult = result;
            return send308Range(res, mediaStore.position);
          });
          return;
        }
        chunkUpload = function(chunk, next) {
          if (mediaStore.position >= fileInfo.instanceLength) {
            MediaFile.closeUpload(fileInfo, mediaStore, function(err, result) {
              return next(err, result);
            });
          }
          return MediaFile.rangeUpload(fileInfo, mediaStore, chunk, function(err, result) {
            return next(err, result);
          });
        };
        req.on('data', function(chunk) {
          req.pause();
          return chunkUpload(chunk, function(err, result) {
            if (err != null) {
              return next(err);
            }
            uploadResult = result;
            return req.resume();
          });
        });
        req.on('end', function() {
          if (uploadResult == null) {
            return MediaFile.closeUpload(fileInfo, mediaStore, function(err, result) {
              if (err != null) {
                return next(err);
              }
              return send308Range(res, result.length);
            });
          } else {
            if (fileInfo.instanceMD5 != null) {
              if (fileInfo.instanceMD5 === uploadResult.md5) {
                return uploadSucceed(fileInfo, req, res);
              } else {
                return Err.sendError(res, Err.CODES.UNMATCHED_MD5);
              }
            } else {
              return uploadSucceed(fileInfo, req, res);
            }
          }
        });
        req.on('close', function() {});
        return req.resume();
      });
    }
  } else {

  }
};

module.exports = mediaUpload;
