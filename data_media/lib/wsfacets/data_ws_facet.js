// Generated by CoffeeScript 1.3.3
var Assert, Datazones, DropReason, IPToDataZone, Log, Memos, Subscriptions, Tags, WSMessageHelper;

Log = require('tern.logger');

Memos = require('../models/memo_mod');

Tags = require('../models/tag_mod');

Subscriptions = require('../models/subscription_mod');

WSMessageHelper = require('tern.ws_message_helper');

IPToDataZone = require('tern.ip_to_datazone');

Assert = require('assert');

Datazones = require('tern.data_zones');

DropReason = {
  CLOSE_REASON_NORMAL: 1000,
  CLOSE_REASON_GOING_AWAY: 1001,
  CLOSE_REASON_PROTOCOL_ERROR: 1002,
  CLOSE_REASON_UNPROCESSABLE_INPUT: 1003,
  CLOSE_REASON_RESERVED: 1004,
  CLOSE_REASON_NOT_PROVIDED: 1005,
  CLOSE_REASON_ABNORMAL: 1006,
  CLOSE_REASON_INVALID_DATA: 1007,
  CLOSE_REASON_POLICY_VIOLATION: 1008,
  CLOSE_REASON_MESSAGE_TOO_BIG: 1009,
  CLOSE_REASON_EXTENSION_REQUIRED: 1010,
  CLOSE_REASON_INTERNAL_SERVER_ERROR: 1011,
  CLOSE_REASON_TLS_HANDSHAKE_FAILED: 1015
};

module.exports.processMessage = function(connection, message, next) {
  var dataZoneToResponse, data_zone, dropError, methodName, processResult, remoteAddress, request, send, sendInternalError, textMessage;
  dropError = function(reasonCode, description, internalMessage) {
    var err;
    err = new Error(description != null ? description : internalMessage);
    err.reasonCode = reasonCode;
    if (internalMessage != null) {
      err.internalMessage = internalMessage;
    }
    return err;
  };
  send = function(req, res, cb) {
    var responseString, response_message;
    try {
      res.method = req.method;
      res.req_ts = req.req_ts;
      response_message = {
        response: res
      };
      responseString = JSON.stringify(response_message);
      return WSMessageHelper.send(connection, responseString, function(err) {
        return cb(err);
      });
    } catch (e) {
      return cb(e);
    }
  };
  sendInternalError = function(req, err, cb) {
    var res, response_message;
    res = {
      method: req.method,
      req_ts: req.req_ts,
      status: -10
    };
    response_message = {
      response: res
    };
    Log.error(err.toString());
    return WSMessageHelper.send(connection, JSON.stringify(response_message), function(e) {
      return cb(e);
    });
  };
  processResult = function(err, req, res) {
    if (err != null) {
      return sendInternalError(req, err, function() {
        if (next != null) {
          return next(err);
        }
      });
    } else {
      return send(req, res, function() {
        if (next != null) {
          return next(null, res);
        }
      });
    }
  };
  try {
    textMessage = WSMessageHelper.parse(message);
    if (Buffer.isBuffer(textMessage)) {
      throw dropError(DropReason.CLOSE_REASON_PROTOCOL_ERROR, "Unsupported message format.");
    }
    try {
      request = JSON.parse(textMessage).request;
    } catch (e) {
      throw dropError(DropReason.CLOSE_REASON_INVALID_DATA, "Bad message format", "Bad message format: \r\nuser_id: " + connection._tern.user_id + "\r\nrequest: " + textMessage);
    }
    if (!request) {
      throw dropError(DropReason.CLOSE_REASON_INVALID_DATA, "Missing root property 'request'", "Missing root property 'request'. \r\nuser_id: " + connection._tern.user_id + "\r\nrequest: " + textMessage);
    }
    request._tern = {
      user_id: connection._tern.user_id,
      scope: connection._tern.scope,
      device_id: connection._tern.device_id,
      contentLang: connection._tern.contentLang,
      data_zone: connection._tern.data_zone
    };
    if (!((request.req_ts != null) && (request.method != null))) {
      throw dropError(DropReason.CLOSE_REASON_INVALID_DATA, "Missing req_ts or method in request header", "Missing req_ts or method in request header. \r\nuser_id: " + connection._tern.user_id + "\r\nrequest: " + textMessage);
    }
    if (request.data == null) {
      throw dropError(DropReason.CLOSE_REASON_INVALID_DATA, "Missing data in request", "Missing data in request. \r\nuser_id: " + connection._tern.user_id + "\r\nrequest: " + textMessage);
    }
    methodName = request.method.toLowerCase();
    switch (methodName) {
      case 'data.memo.upload':
        return Memos.upload(request, function(err, res) {
          return processResult(err, request, res);
        });
      case 'data.tag.upload':
        return Tags.upload(request, function(err, res) {
          return processResult(err, request, res);
        });
      case 'data.subscription.subscribe':
        return Subscriptions.subscribe(request, connection, function(err, res) {
          return processResult(err, request, res);
        });
      case 'data.subscription.unsubscribe':
        return Subscriptions.unsubscribe(request, connection, function(err, res) {
          return processResult(err, request, res);
        });
      case 'data.subscription.get':
        return Subscriptions.get(connection, function(err, res) {
          return processResult(err, request, res);
        });
      case 'media.host.get':
        dataZoneToResponse = function(data_zone) {
          var host, res;
          host = Datazones.getMediaConnect(data_zone).host;
          Assert(host != null, "Host of media server in '" + data_zone + "'' zone can not be null.");
          res = {
            status: 0,
            result: {
              host: host
            }
          };
          return processResult(null, request, res);
        };
        remoteAddress = connection.remoteAddress;
        if (IPToDataZone.isInternalIP(remoteAddress) || IPToDataZone.isLoopbackIP(remoteAddress)) {
          data_zone = connection._tern.data_zone;
          return dataZoneToResponse(data_zone);
        } else {
          return IPToDataZone.lookup(remoteAddress, function(err, data_zone) {
            return dataZoneToResponse(data_zone);
          });
        }
        break;
      default:
        throw dropError(DropReason.CLOSE_REASON_INVALID_DATA, "Unknown method in request header", "Missing method. \r\nclient_id: " + request.client_id + "\r\nrequest: " + textMessage);
    }
  } catch (e) {
    return next(e);
  }
};
