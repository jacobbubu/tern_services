// Generated by CoffeeScript 1.3.3
var Chunk, GridStoreStream, Stream, exports;

Stream = require('stream');

Chunk = require('mongodb').Chunk;

Chunk.prototype.seek = function(pos) {
  if ((0 <= pos && pos < this.length())) {
    return this.internalPosition = pos;
  }
};

GridStoreStream = function(gstore, options) {
  var end, self, start, _ref, _ref1, _ref2;
  if (!(this instanceof GridStoreStream)) {
    return new GridStoreStream(media_id, gstore);
  }
  Stream.call(this);
  options = options != null ? options : {};
  this.autoclose = (_ref = options.autoclose) != null ? _ref : true;
  start = (_ref1 = options.start) != null ? _ref1 : 0;
  end = (_ref2 = options.end) != null ? _ref2 : gstore.length - 1;
  this.firstChunkNumber = Math.floor(start / gstore.chunkSize);
  this.firstChunkPos = start - this.firstChunkNumber * gstore.chunkSize;
  this.lastChunkNumber = Math.floor((end + 1) / gstore.chunkSize);
  this.lastChunkPos = end - this.lastChunkNumber * gstore.chunkSize;
  this.currentChunkNumber = this.firstChunkNumber;
  this.gstore = gstore;
  this.completedLength = 0;
  this.paused = false;
  this.readable = true;
  this.pendingChunk = null;
  this.executing = false;
  self = this;
  return process.nextTick(function() {
    return self._execute();
  });
};

GridStoreStream.prototype.__proto__ = Stream.prototype;

GridStoreStream.prototype._execute = function() {
  var data, first, gstore, last, lengthToRead, self;
  if (this.paused || !this.readable) {
    return;
  }
  gstore = this.gstore;
  self = this;
  self.executing = true;
  first = self.currentChunkNumber === self.firstChunkNumber;
  last = false;
  if (self.currentChunkNumber === self.lastChunkNumber) {
    self.executing = false;
    last = true;
  }
  if (self.currentChunkNumber !== gstore.currentChunk.chunkNumber) {
    return gstore._nthChunk(self.currentChunkNumber, function(err, chunk) {
      if (err != null) {
        self.readable = false;
        self.emit("error", err);
        self.executing = false;
        return;
      }
      self.pendingChunk = chunk;
      if (self.paused === true) {
        self.executing = false;
        return;
      }
      gstore.currentChunk = self.pendingChunk;
      return self._execute();
    });
  } else {
    if (first) {
      if (self.firstChunkPos > 0) {
        gstore.currentChunk.seek(self.firstChunkPos);
      }
      if (last) {
        lengthToRead = self.lastChunkPos - self.firstChunkPos + 1;
      } else {
        lengthToRead = gstore.currentChunk.length() - self.firstChunkPos;
      }
    } else {
      lengthToRead = last ? self.lastChunkPos + 1 : gstore.currentChunk.length();
    }
    data = gstore.currentChunk.readSlice(lengthToRead);
    if ((data != null) && gstore.currentChunk.chunkNumber === self.currentChunkNumber) {
      self.completedLength += data.length;
      self.pendingChunk = null;
      self.emit("data", data);
    }
    if (last) {
      self.readable = false;
      self.emit("end");
      if (self.autoclose === true) {
        if (gstore.mode[0] === "w") {
          return gstore.close(function(err, doc) {
            if (err != null) {
              return self.emit("error", err);
            }
            self.readable = false;
            return self.emit("close", doc);
          });
        } else {
          self.readable = false;
          return self.emit("close");
        }
      }
    } else {
      self.currentChunkNumber += 1;
      return gstore._nthChunk(self.currentChunkNumber, function(err, chunk) {
        if (err != null) {
          self.readable = false;
          self.emit("error", err);
          self.executing = false;
          return;
        }
        self.pendingChunk = chunk;
        if (self.paused === true) {
          self.executing = false;
          return;
        }
        gstore.currentChunk = self.pendingChunk;
        return self._execute();
      });
    }
  }
};

GridStoreStream.prototype.pause = function() {
  if (!this.executing) {
    return this.paused = true;
  }
};

GridStoreStream.prototype.destroy = function() {
  this.readable = false;
  return this.emit("close");
};

GridStoreStream.prototype.resume = function() {
  var self;
  if (!(this.paused && this.readable)) {
    return;
  }
  this.paused = false;
  self = this;
  return process.nextTick(function() {
    return self._execute();
  });
};

exports = module.exports = GridStoreStream;
