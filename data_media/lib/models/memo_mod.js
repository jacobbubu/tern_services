// Generated by CoffeeScript 1.3.3
var Assert, Async, Checker, DB, DBKeys, Err, Log, MaxMediaSize, MaxTS, MaxTextSize, MediaAgent, OP, ParamRules, Utils, ValidContentTypes, coreClass, memoModel, _MemoModel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  _this = this;

Log = require('tern.logger');

Err = require('tern.exceptions');

Checker = require('tern.param_checker');

DB = require('tern.database');

Utils = require('tern.utils');

Async = require("async");

Assert = require("assert");

DBKeys = require("./dbkeys");

MediaAgent = require("../agents/media_agent");

OP = {
  'add': 1,
  'update': 2,
  'delete': 3
};

ValidContentTypes = ['image/png', 'image/jpeg', 'image/gif', 'audio/mpeg', 'video/h264', 'video/mp4'];

MaxMediaSize = 100 * 1024 * 1024;

MaxTextSize = 2 * 1024;

MaxTS = 999999999999999;

ParamRules = {
  'op': {
    'UNSUPPORTED': [1, 2, 3]
  },
  'created_at': {
    'ISODATE': true
  },
  'updated_at': {
    'ISODATE': true
  },
  'deleted_at': {
    'ISODATE': true
  },
  'media_meta.content_type': {
    'UNSUPPORTED/i': ValidContentTypes
  },
  'media_meta.content_length': {
    'INTEGER': true,
    'RANGE': {
      min: 1,
      max: MaxMediaSize
    }
  },
  'media_meta.md5': {
    'LENGTH': {
      min: 32,
      max: 32
    }
  },
  'text': {
    'LENGTH': {
      min: 0,
      max: MaxTextSize
    }
  },
  'geo.lat': {
    'RANGE': {
      min: -90,
      max: 90
    }
  },
  'geo.lng': {
    'RANGE': {
      min: -180,
      max: 180
    }
  },
  'mid': {
    'NAME_INTEGER': true
  },
  'old_ts': {
    'STRING_INTEGER': true
  },
  'tags': {
    'ARRAY': true
  }
};

coreClass = (function() {
  var _instance;

  function coreClass() {}

  _instance = void 0;

  coreClass.get = function() {
    return _instance != null ? _instance : _instance = new _MemoModel;
  };

  return coreClass;

})();

_MemoModel = (function() {

  function _MemoModel() {
    this.upload = __bind(this.upload, this);
    this.db = DB.getDB('userDataDB');
  }

  _MemoModel.prototype.upload = function(request, next) {
    var changeLogKey, data, device_id, devicesKey, error, finalResponse, index, processItem, res, tagMidBaseKey, user_id, value, _i, _len,
      _this = this;
    user_id = request._tern.user_id;
    device_id = request._tern.device_id;
    Assert(user_id != null, "user_id should not be null!");
    Assert(device_id != null, "device_id should not be null!");
    changeLogKey = DBKeys.MemosChangeLogKey(user_id, device_id);
    tagMidBaseKey = DBKeys.TidMidBaseKey(user_id);
    devicesKey = DBKeys.DevicesKey(user_id);
    processItem = function(memo, cb) {
      var add, addArgsCheck, del, deleteArgsCheck, deleteMedia, error, errorResponse, memosKey, sameArgsCheck, savingCallback, tagIdxArray, upd, updateArgsCheck;
      errorResponse = function(status, error) {
        var res;
        res = {};
        if (memo.op != null) {
          res.op = memo.op;
        }
        if (memo.mid != null) {
          res.mid = memo.mid;
        }
        res._order = memo._order;
        res.status = status;
        res.error = error;
        return res;
      };
      sameArgsCheck = function(error) {
        var index, tag, _i, _len, _ref;
        error = Checker.collectErrors('mid', memo, ParamRules, error);
        if (memo.media_meta != null) {
          if (memo.media_meta.content_type != null) {
            error = Checker.collectErrors('media_meta.content_type', memo, ParamRules, error);
          }
          if (memo.media_meta.content_length != null) {
            error = Checker.collectErrors('media_meta.content_length', memo, ParamRules, error);
          }
          if (memo.media_meta.md5 != null) {
            error = Checker.collectErrors('media_meta.md5', memo, ParamRules, error);
          }
        }
        if (memo.text != null) {
          error = Checker.collectErrors('text', memo, ParamRules, error);
        }
        if (memo.geo != null) {
          error = Checker.collectErrors('geo.lat', memo, ParamRules, error);
          error = Checker.collectErrors('geo.lng', memo, ParamRules, error);
        }
        if (memo.tags != null) {
          if (Utils.type(memo.tags) !== 'array') {
            error = Checker.collectErrors('tags', memo, ParamRules, error);
          } else {
            _ref = memo.tags;
            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
              tag = _ref[index];
              error = Checker.checkRulesWithError("tags[" + index + "].tid", tag.tid, {
                'NAME_INTEGER': true
              }, error);
            }
          }
        }
        return error;
      };
      addArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('created_at', memo, ParamRules, error);
        if (!(memo.media_meta != null) && !(memo.text != null)) {
          if (error == null) {
            error = {};
          }
          error.media_meta = ["REQUIRED_EITHER:media_meta:text"];
        }
        return sameArgsCheck(error);
      };
      updateArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('updated_at', memo, ParamRules, error);
        error = Checker.collectErrors('old_ts', memo, ParamRules, error);
        return sameArgsCheck(error);
      };
      deleteArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('deleted_at', memo, ParamRules, error);
        error = Checker.collectErrors('old_ts', memo, ParamRules, error);
        return sameArgsCheck(error);
      };
      tagIdxArray = function(tagsObject) {
        var tagId, tagIdxs, tagKey, v;
        tagIdxs = [];
        for (tagId in tagsObject) {
          v = tagsObject[tagId];
          tagKey = v.key;
          tagIdxs.merge(Utils.keyToTagIdx(v.key));
        }
        return tagIdxs = tagIdxs.unique();
      };
      deleteMedia = function(media_zone, media_id) {
        return process.nextTick(function() {
          return MediaAgent.deleteMedia(media_zone, media_id, function(err) {
            if (err != null) {
              return Log.error("Error deleteMedia: " + (err.toString()) + "\r\nData Zone: " + media_zone + ", media_id: " + media_id);
            }
          });
        });
      };
      add = function(next) {
        var savingObject, script;
        savingObject = {
          ts: Utils.getTimestamp(),
          op: memo.op,
          mid: memo.mid,
          created_at: memo.created_at,
          created_by: user_id,
          device_id: device_id
        };
        if (memo.text != null) {
          savingObject.text = memo.text;
        }
        if (memo.media_meta != null) {
          savingObject.media_meta = JSON.stringify(memo.media_meta);
        }
        if (memo.geo != null) {
          savingObject.geo = JSON.stringify(memo.geo);
        }
        if (memo.tags != null) {
          savingObject.tags = JSON.stringify(memo.tags);
        }
        script = "local memosKey = KEYS[1]\nlocal memosChangeLogKey = KEYS[2]\nlocal devicesKey = KEYS[3]\nlocal tagMidBaseKey = ARGV[1]..'/'\nlocal score = ARGV[2]\nlocal memo_json = ARGV[3]\nlocal affectedCount\n\nlocal memoExist = redis.call('EXISTS', memosKey)\n\nif memoExist == 1 then\n  return { -2, redis.call('HGETALL', memosKey) }\nend\n\nlocal memo = cjson.decode(memo_json)\n\n-- Saving memo data\nfor k, v in pairs(memo) do\n  if k ~= 'op' then\n    redis.call('HSET', memosKey, k, v)\n  end\nend\n\n-- tid_mid mapping\nif memo.tags then\n  local tags = cjson.decode(memo.tags)\n  for _, tag in pairs(tags) do\n    affectedCount = redis.call('ZADD', tagMidBaseKey..tag.tid, score, memo.mid)\n  end\nend\n\n-- Add Device, only for 'add' op\nredis.call('SADD', devicesKey, memo.device_id)\n-- Loggin changes\nredis.call('ZADD', memosChangeLogKey, memo.ts, memo_json)\n\nreturn {0}";
        return _this.db.run_script(script, 3, memosKey, changeLogKey, devicesKey, tagMidBaseKey, +(new Date), JSON.stringify(savingObject), function(err, res) {
          var result;
          if (err != null) {
            return next(err);
          }
          if (res[0] === 1) {
            result = Utils.redisArrayToObject(res[1]);
            if (result.media_meta != null) {
              result.media_meta = JSON.parse(result.media_meta);
            }
            if (result.geo != null) {
              result.geo = JSON.parse(result.geo);
            }
            if (result.tags != null) {
              result.tags = JSON.parse(result.tags);
            }
          } else {
            result = {
              ts: savingObject.ts
            };
          }
          result.status = res[0];
          result._order = memo._order;
          result.mid = memo.mid;
          result.op = memo.op;
          return next(null, result);
        });
      };
      upd = function(next) {
        var old_ts, savingObject, script;
        old_ts = memo.old_ts;
        savingObject = {
          ts: Utils.getTimestamp(),
          op: memo.op,
          mid: memo.mid,
          updated_at: memo.updated_at,
          updated_by: user_id,
          device_id: device_id
        };
        if (memo.text != null) {
          savingObject.text = memo.text;
        }
        if (memo.media_meta != null) {
          savingObject.media_meta = JSON.stringify(memo.media_meta);
        }
        if (memo.geo != null) {
          savingObject.geo = JSON.stringify(memo.geo);
        }
        if (memo.tags != null) {
          savingObject.tags = JSON.stringify(memo.tags);
        }
        script = "local memosKey          = KEYS[1]\nlocal memosChangeLogKey = KEYS[2]\n\nlocal old_ts        = ARGV[1]\nlocal tagMidBaseKey = ARGV[2]..'/'\nlocal score         = ARGV[3]\n\nlocal memo_json     = ARGV[4]\nlocal memo          = cjson.decode(memo_json)\nlocal mid           = memo['mid']\nlocal affectedCount\n\nlocal function contains(table, element)\n  for _, value in pairs(table) do\n    if value == element then\n      return true\n    end\n  end\n  return false\nend\n\nlocal curr_ts = redis.call('HGET', memosKey, 'ts')\nif curr_ts then\n  -- Has newer version?\n  if curr_ts > old_ts then\n    return { 1, redis.call('HGETALL', memosKey) }\n  end\nelse\n  return {-3}\nend\n\nlocal oldMediaMeta = redis.call('HGET', memosKey, 'media_meta')\n\nlocal oldTags = redis.call('HGET', memosKey, 'tags')\nlocal oldTagsArr = {}\nif oldTags then\n  oldTags = cjson.decode(oldTags)\n  for _, tag in pairs(oldTags) do\n    oldTagsArr[#oldTagsArr+1] = tag.tid\n  end\nend\nlocal newTags = memo.tags\nlocal newTagsArr = {}\nif newTags then\n  newTags = cjson.decode(newTags)\n  for _, tag in pairs(newTags) do\n    newTagsArr[#newTagsArr+1] = tag.tid\n  end\nend\n\n-- Saving memo data\nfor k, v in pairs(memo) do\n  if k ~= 'op' then          \n    if k == 'media_meta' then\n      redis.call('HDEL', memosKey, 'text')\n    end\n    if k == 'text' then\n      redis.call('HDEL', memosKey, 'media_meta')\n    end              \n    redis.call('HSET', memosKey, k, v)\n  end\nend\n\n-- tid_mid we need to remove\nfor _, tid in pairs(oldTagsArr) do\n  if contains(newTagsArr, tid) == false then\n    affectedCount = redis.call('ZREM', tagMidBaseKey..tid, mid)\n  end\nend\n\n-- tid_mid we need to add\nfor _, tid in pairs(newTagsArr) do\n  if contains(oldTagsArr, tid) == false then\n    affectedCount = redis.call('ZADD', tagMidBaseKey..tid, score, mid)\n  end\nend\n\n-- Loggin changes\nredis.call('ZADD', memosChangeLogKey, memo.ts, memo_json)\n\nreturn {0, oldMediaMeta}";
        return _this.db.run_script(script, 2, memosKey, changeLogKey, old_ts, tagMidBaseKey, +(new Date), JSON.stringify(savingObject), function(err, res) {
          var oldMediaMeta, result;
          if (err != null) {
            return next(err);
          }
          switch (res[0]) {
            case 0:
              result = {
                mid: savingObject.mid,
                ts: savingObject.ts
              };
              oldMediaMeta = res[1];
              if ((oldMediaMeta != null ? oldMediaMeta.media_zone : void 0) != null) {
                deleteMedia(oldMediaMeta != null ? oldMediaMeta.media_zone : void 0, memo.mid);
              }
              break;
            case 1:
              result = Utils.redisArrayToObject(res[1]);
              break;
            case -3:
              result = {
                mid: savingObject.mid
              };
          }
          result._order = memo._order;
          result.op = memo.op;
          result.status = res[0];
          if (result.status === 1) {
            if (result.media_meta != null) {
              result.media_meta = JSON.parse(result.media_meta);
            }
            if (result.geo != null) {
              result.geo = JSON.parse(result.geo);
            }
            if (result.tags != null) {
              result.tags = JSON.parse(result.tags);
            }
          }
          return next(null, result);
        });
      };
      del = function(next) {
        var new_ts, script;
        new_ts = Utils.getTimestamp();
        script = "local memosKey          = KEYS[1]\nlocal memosChangeLogKey = KEYS[2]\n\nlocal user_id       = ARGV[1]\nlocal device_id     = ARGV[2]\nlocal mid           = ARGV[3]\nlocal old_ts        = ARGV[4]\nlocal new_ts        = ARGV[5]\nlocal deleted_at    = ARGV[6]\nlocal tagMidBaseKey = ARGV[7]..'/'\nlocal affectedCount\n\nlocal curr_ts = redis.call('HGET', memosKey, 'ts')\nif curr_ts then\n  -- Has newer version?\n  if curr_ts > old_ts then\n    return { 1, redis.call('HGETALL', memosKey) }\n  end\nelse\n  return {-3}\nend\n\nlocal oldTags = redis.call('HGET', memosKey, 'tags')\nif oldTags then\n  oldTags = cjson.decode(oldTags)\nelse\n  oldTags = {}\nend\n\nlocal mediaMeta = redis.call('HGET', memosKey, 'media_meta')\n\nredis.call('DEL', memosKey)\n\nfor _, tag in pairs(oldTags) do\n  affectedCount = redis.call('ZREM', tagMidBaseKey..tag.tid, mid)\nend          \n\n-- Loggin changes\nlocal logContent = { op = 3, mid = mid, ts = new_ts, device_id = device_id, deleted_by = user_id, deleted_at = deleted_at }\nredis.call('ZADD', memosChangeLogKey, new_ts, cjson.encode(logContent))\n\nreturn {0, mediaMeta}";
        return _this.db.run_script(script, 2, memosKey, changeLogKey, user_id, device_id, memo.mid, memo.old_ts, new_ts, memo.deleted_at, tagMidBaseKey, function(err, res) {
          var media_meta, result;
          if (err != null) {
            return next(err);
          }
          switch (res[0]) {
            case 0:
              result = {
                mid: memo.mid,
                ts: new_ts
              };
              media_meta = JSON.parse(res[1]);
              if ((media_meta != null ? media_meta.media_zone : void 0) != null) {
                deleteMedia(media_meta.media_zone, memo.mid);
              }
              break;
            case 1:
              result = Utils.redisArrayToObject(res[1]);
              break;
            case -3:
              result = {
                mid: memo.mid
              };
          }
          result._order = memo._order;
          result.op = memo.op;
          result.status = res[0];
          if (result.status === 1) {
            if (result.media_meta != null) {
              result.media_meta = JSON.parse(result.media_meta);
            }
            if (result.geo != null) {
              result.geo = JSON.parse(result.geo);
            }
            if (result.tags != null) {
              result.tags = JSON.parse(result.tags);
            }
          }
          return next(null, result);
        });
      };
      try {
        error = Checker.collectErrors('op', memo, ParamRules, null);
      } catch (e) {
        return cb(e);
      }
      if (error != null) {
        finalResponse.push(errorResponse(-1, error));
        return cb();
      }
      try {
        switch (memo.op) {
          case 1:
            error = addArgsCheck();
            break;
          case 2:
            error = updateArgsCheck();
            break;
          case 3:
            error = deleteArgsCheck();
        }
      } catch (e) {
        return cb(e);
      }
      if (error != null) {
        finalResponse.push(errorResponse(-1, error));
        return cb();
      }
      savingCallback = function(err, res) {
        if (err != null) {
          return cb(err);
        }
        finalResponse.push(res);
        return cb();
      };
      memosKey = DBKeys.MemosKey(user_id, memo.mid);
      switch (memo.op) {
        case 1:
          return add(savingCallback);
        case 2:
          return upd(savingCallback);
        case 3:
          return del(savingCallback);
      }
    };
    data = request.data;
    error = Checker.checkRulesWithError("data", data, {
      'ARRAY': true
    }, error);
    if (error != null) {
      res = {
        status: -1,
        error: error
      };
      return next(null, res);
    }
    finalResponse = [];
    for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
      value = data[index];
      data[index]._order = index;
    }
    return Async.forEach(data, processItem, function(err) {
      var _j, _len1;
      if (err != null) {
        return next(err);
      }
      finalResponse.sort(function(m1, m2) {
        return m1._order - m2._order;
      });
      for (_j = 0, _len1 = finalResponse.length; _j < _len1; _j++) {
        res = finalResponse[_j];
        delete res._order;
      }
      return next(null, finalResponse);
    });
  };

  _MemoModel.prototype.mediaUriWriteback = function(changedMemo, next) {
    var device_id, media_meta, mid, request, updated_at, user_id;
    mid = changedMemo.mid;
    user_id = changedMemo.user_id;
    device_id = changedMemo.device_id;
    updated_at = changedMemo.updated_at;
    media_meta = changedMemo.media_meta;
    Assert(mid != null, "mid should not be null!");
    Assert(user_id != null, "user_id should not be null!");
    Assert(device_id != null, "device_id should not be null!");
    Assert(media_meta != null, "media_meta should not be null!");
    request = {
      _tern: {
        user_id: user_id,
        device_id: device_id
      },
      data: [
        {
          op: 2,
          mid: mid,
          old_ts: Utils.maxTimestamp,
          updated_at: updated_at,
          media_meta: changedMemo.media_meta
        }
      ]
    };
    return this.upload(request, function(err, res) {
      return next(err, res);
    });
  };

  return _MemoModel;

})();

/*
*/


/*
# Module return Exports
*/


memoModel = coreClass.get();

module.exports.upload = function(request, next) {
  return memoModel.upload(request, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};

module.exports.mediaUriWriteback = function(changedMemo, next) {
  return memoModel.mediaUriWriteback(changedMemo, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};
