// Generated by CoffeeScript 1.3.3
var Assert, Async, Checker, DB, DBKeys, Err, Log, ParamRules, Utils, coreClass, tagModel, _TagModel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  _this = this;

Log = require('tern.logger');

Err = require('tern.exceptions');

Checker = require('tern.param_checker');

DB = require('tern.database');

Utils = require('tern.utils');

Async = require("async");

Assert = require("assert");

DBKeys = require("./dbkeys");

ParamRules = {
  'op': {
    'UNSUPPORTED': [1, 2, 3]
  },
  'tid': {
    'NAME_INTEGER': true
  },
  'parent': {
    'NAME_INTEGER': true
  },
  'created_at': {
    'ISODATE': true
  },
  'updated_at': {
    'ISODATE': true
  },
  'deleted_at': {
    'ISODATE': true
  },
  'value': {
    'REQUIRED': true
  },
  'old_ts': {
    'STRING_INTEGER': true
  },
  'key': {
    'TAG_KEY': true
  }
};

coreClass = (function() {
  var _instance;

  function coreClass() {}

  _instance = void 0;

  coreClass.get = function() {
    return _instance != null ? _instance : _instance = new _TagModel;
  };

  return coreClass;

})();

_TagModel = (function() {

  function _TagModel() {
    this.upload = __bind(this.upload, this);
    this.db = DB.getDB('userDataDB');
  }

  _TagModel.prototype.upload = function(request, next) {
    var changeLogKey, data, device_id, devicesKey, error, finalResponse, index, memoBase, memoChangeLogKey, processItem, res, tagKeyBase, tagKeyMappingBase, tidMidBaseKey, user_id, value, _i, _len,
      _this = this;
    user_id = request._tern.user_id;
    device_id = request._tern.device_id;
    Assert(user_id != null, "user_id should not be null!");
    Assert(device_id != null, "device_id should not be null!");
    tagKeyBase = DBKeys.TagsBase(user_id);
    tagKeyMappingBase = DBKeys.TagKeyMappingBase(user_id);
    changeLogKey = DBKeys.TagsChangeLogKey(user_id, device_id);
    tidMidBaseKey = DBKeys.TidMidBaseKey(user_id);
    memoBase = DBKeys.MemosBase(user_id);
    memoChangeLogKey = DBKeys.MemosChangeLogKey(user_id, device_id);
    devicesKey = DBKeys.DevicesKey(user_id);
    processItem = function(tag, cb) {
      var add, addArgsCheck, del, deleteArgsCheck, error, errorResponse, sameArgsCheck, savingCallback, upd, updateArgsCheck;
      errorResponse = function(status, error) {
        var res;
        res = {};
        if (tag.op != null) {
          res.op = tag.op;
        }
        if (tag.tid != null) {
          res.tid = tag.tid;
        }
        res._order = tag._order;
        res.status = status;
        res.error = error;
        return res;
      };
      sameArgsCheck = function(error) {
        error = Checker.collectErrors('tid', tag, ParamRules, error);
        error = Checker.collectErrors('key', tag, ParamRules, error);
        if (tag.parent != null) {
          error = Checker.collectErrors('parent', tag, ParamRules, error);
        }
        return error;
      };
      addArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('created_at', tag, ParamRules, error);
        return sameArgsCheck(error);
      };
      updateArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('tid', tag, ParamRules, error);
        error = Checker.collectErrors('updated_at', tag, ParamRules, error);
        error = Checker.collectErrors('old_ts', tag, ParamRules, error);
        return sameArgsCheck(error);
      };
      deleteArgsCheck = function() {
        var error;
        error = null;
        error = Checker.collectErrors('tid', tag, ParamRules, error);
        error = Checker.collectErrors('deleted_at', tag, ParamRules, error);
        return error = Checker.collectErrors('old_ts', tag, ParamRules, error);
      };
      add = function(next) {
        var savingObject, script, _ref;
        savingObject = {
          ts: Utils.getTimestamp(),
          op: tag.op,
          tid: tag.tid,
          created_at: tag.created_at,
          created_by: 'user:' + user_id,
          device_id: device_id,
          key: tag.key,
          parent: (_ref = tag.parent) != null ? _ref : '0000',
          children: JSON.stringify([]),
          value: JSON.stringify(tag.value)
        };
        script = "local tagKeyBase        = ARGV[1]..'/'\nlocal tagKeyMappingBase = ARGV[2]..'/'\nlocal tagChangeLogKey   = ARGV[3]\nlocal devicesKey        = ARGV[4]\nlocal tag_json          = ARGV[5]\nlocal tag               = cjson.decode(tag_json)\n\nlocal tagKey   = tagKeyBase..tag.tid\nlocal tagExist = redis.call('EXISTS', tagKey)\n\nlocal function add(t, ele)    \n  for _, value in pairs(t) do\n    if value == ele then\n      return\n    end\n  end\n  t[#t+1] = ele\nend\n\nif tagExist == 1 then\n  return { -2, redis.call('HGETALL', tagKey) }\nend\n\nlocal existingTid = redis.call('GET', tagKeyMappingBase..tag.key)\nif existingTid then\n  if existingTid ~= tag.tid then\n    return { -6, redis.call('HGETALL', tagKeyBase..existingTid) }\n  end\nend\n\n-- Check parent and add tid to parent.children\nif tag.parent ~= '0000' then\n  local parentKey = tagKeyBase..tag.parent\n  if redis.call('EXISTS', parentKey) == 1 then\n    local children = cjson.decode(redis.call('HGET', parentKey, 'children'))\n    add(children, tag.tid)\n    redis.call('HSET', parentKey, 'children', cjson.encode(children))\n  else\n    return {-5}\n  end\nend\n\nif existingTid == false then\n  redis.call('SET', tagKeyMappingBase..tag.key, tag.tid)\nend\n\n-- Saving tag data\nfor k, v in pairs(tag) do\n  if k ~= 'op' then\n    redis.call('HSET', tagKey, k, v)\n  end\nend\n\n-- Add Device, only for 'add' op\nredis.call('SADD', devicesKey, tag.device_id)\n-- Loggin changes\nredis.call('ZADD', tagChangeLogKey, tag.ts, tag_json)\n\nreturn {0}";
        return _this.db.run_script(script, 0, tagKeyBase, tagKeyMappingBase, changeLogKey, devicesKey, JSON.stringify(savingObject), function(err, res) {
          var result;
          if (err != null) {
            return next(err);
          }
          switch (res[0]) {
            case 0:
              result = {
                ts: savingObject.ts,
                tid: tag.tid
              };
              break;
            case -2:
            case -6:
              result = Utils.redisArrayToObject(res[1]);
              break;
            case -5:
              ({
                tid: tag.tid
              });
          }
          delete result.children;
          result.status = res[0];
          result._order = tag._order;
          result.op = tag.op;
          if (result.value != null) {
            result.value = JSON.parse(result.value);
          }
          return next(null, result);
        });
      };
      upd = function(next) {
        var old_ts, savingObject, script, _ref;
        old_ts = tag.old_ts;
        savingObject = {
          ts: Utils.getTimestamp(),
          op: tag.op,
          tid: tag.tid,
          updated_at: tag.updated_at,
          updated_by: 'user:' + user_id,
          device_id: device_id,
          key: tag.key,
          value: JSON.stringify(tag.value),
          parent: (_ref = tag.parent) != null ? _ref : '0000'
        };
        script = "local tagKeyBase        = ARGV[1]..'/'\nlocal tagKeyMappingBase = ARGV[2]..'/'\nlocal tagChangeLogKey   = ARGV[3]\n\nlocal old_ts     = ARGV[4]\nlocal tag_json   = ARGV[5]\nlocal devicesKey = ARGV[6]\n\nlocal tag       = cjson.decode(tag_json)\nlocal tagKey    = tagKeyBase..tag.tid\n\nlocal function add(t, ele)    \n  for _, value in pairs(t) do\n    if value == ele then\n      return\n    end\n  end\n  t[#t+1] = ele\nend\n\nlocal function remove(t, ele)    \n  for i, value in pairs(t) do\n    if value == ele then\n      table.remove(t, i)\n    end\n  end\nend\n\nlocal curr_ts = redis.call('HGET', tagKey, 'ts')\nif curr_ts then\n  -- Has newer version?\n  if curr_ts > old_ts then\n    return { 1, redis.call('HGETALL', tagKey) }\n  end\nelse\n  return {-3}\nend\n\n-- new key exists and mapps to different tid?\nlocal newTagKeyMappingKey = tagKeyMappingBase..tag.key\nlocal tid_of_new_key = redis.call('GET', newTagKeyMappingKey)\n\nif tid_of_new_key then\n  if tid_of_new_key ~= tag.tid then\n    return {-6, tid_of_new_key}\n  end\nend\n\n-- Rename key name of old tagkey to new one\nlocal oldTagKey = redis.call('HGET', tagKey, 'key')\nlocal oldTagKeyMappingKey = tagKeyMappingBase..oldTagKey\n\nif oldTagKeyMappingKey ~= newTagKeyMappingKey then\n  redis.call('RENAME', oldTagKeyMappingKey, newTagKeyMappingKey)\nend\n\n-- Check parent of old tag and add tid to parent.children\nlocal oldParent = redis.call('HGET', tagKey, 'parent')\nlocal parentKey\nlocal children\n\nif oldParent ~= tag.parent then\n  -- Check parent of new tag and add tid to parent.children\n  if tag.parent ~= '0000' then\n    parentKey = tagKeyBase..tag.parent\n    if redis.call('EXISTS', parentKey) == 1 then\n      children = cjson.decode(redis.call('HGET', parentKey, 'children'))\n      add(children, tag.tid)\n      redis.call('HSET', parentKey, 'children', cjson.encode(children))\n    else\n      return {-5}\n    end\n  end            \n\n  if oldParent ~= '0000' then\n    parentKey = tagKeyBase..oldParent\n    if redis.call('EXISTS', parentKey) == 1 then\n      children = cjson.decode(redis.call('HGET', parentKey, 'children'))\n      remove(children, tag.tid)\n      redis.call('HSET', parentKey, 'children', cjson.encode(children))\n    end\n  end\nend\n\n-- Saving tag data\nfor k, v in pairs(tag) do\n  if k ~= 'op' then\n    redis.call('HSET', tagKey, k, v)\n  end\nend\n\n-- Add Device, only for 'add' op\nredis.call('SADD', devicesKey, tag.device_id)\n-- Loggin changes\nredis.call('ZADD', tagChangeLogKey, tag.ts, tag_json)\n\nreturn {0}";
        return _this.db.run_script(script, 0, tagKeyBase, tagKeyMappingBase, changeLogKey, old_ts, JSON.stringify(savingObject), devicesKey, function(err, res) {
          var result;
          if (err != null) {
            return next(err);
          }
          switch (res[0]) {
            case 0:
              result = {
                tid: savingObject.tid,
                ts: savingObject.ts
              };
              break;
            case 1:
              result = Utils.redisArrayToObject(res[1]);
              break;
            case -3:
            case -5:
              result = {
                tid: savingObject.tid
              };
              break;
            case -6:
              result = {
                tid_of_new_key: res[1]
              };
          }
          delete result.children;
          result._order = tag._order;
          result.op = tag.op;
          result.status = res[0];
          return next(null, result);
        });
      };
      del = function(next) {
        var deleteObject, memoChangeObject, new_ts, script;
        new_ts = Utils.getTimestamp();
        deleteObject = {
          ts: new_ts,
          op: 3,
          tid: tag.tid,
          deleted_at: tag.deleted_at,
          deleted_by: 'user:' + user_id,
          device_id: device_id
        };
        memoChangeObject = {
          op: 2,
          updated_at: tag.deleted_at,
          updated_by: user_id,
          device_id: device_id
        };
        script = "local tagKeyBase        = ARGV[1]..'/'\nlocal tagKeyMappingBase = ARGV[2]..'/'\nlocal tidMidBaseKey     = ARGV[3]..'/'\nlocal memoBase          = ARGV[4]..'/'\nlocal tagChangeLogKey   = ARGV[5]\nlocal memoChangeLogKey  = ARGV[6]\nlocal old_ts            = ARGV[7]\nlocal memoChangeObject  = cjson.decode(ARGV[8])\nlocal tagObject         = cjson.decode(ARGV[9])\nlocal devicesKey        = ARGV[10]\n          \nlocal ts                = tonumber(tagObject.ts)\n\nlocal tagKey            = tagKeyBase..tagObject.tid\n\nlocal curr_ts = redis.call('HGET', tagKey, 'ts')\nif curr_ts then\n  -- Has newer version?\n  if curr_ts > old_ts then\n    return { 1, redis.call('HGETALL', tagKey) }\n  end\nelse\n  return {-3}\nend\n\n-- find out all children then put them into tagsNeedDeleted\nlocal tagsNeedDeleted = {tagObject.tid}\n\nlocal function array_concat(arr)\n  for _, v in ipairs(arr) do\n    tagsNeedDeleted[#tagsNeedDeleted+1] = v\n  end\n  return\nend\n\nlocal function getChildren(tagKey)\n  local json = redis.call('HGET', tagKey, 'children')\n  if json ~= false then\n    local arr = cjson.decode(json)\n    array_concat(arr)\n    for k, v in pairs(arr) do\n      getChildren(tagKeyBase..v)\n    end\n  else\n    return\n  end\nend\n\ngetChildren(tagKey)\n\nlocal function remove(t, ele)    \n  for i, value in pairs(t) do\n    if value == ele then\n      table.remove(t, i)\n    end\n  end\nend\n\nlocal function deleteOneTag(tid)\n  tagKey = tagKeyBase..tid\n  tagObject.tid = tid\n  tagObject.ts = string.format('%u', ts)\n  ts = ts + 1 \n\n  --Delete tagkey_to_tid\n  local oldTagKey = redis.call('HGET', tagKey, 'key')\n  if oldTagKey ~= false then\n    local oldTagKeyMappingKey = tagKeyMappingBase..oldTagKey\n    redis.call('DEL', oldTagKeyMappingKey)\n  end\n\n  -- Get parent of deleted tag and remove tid from parent.children\n  local oldParent = redis.call('HGET', tagKey, 'parent')\n  local parentKey\n  local children\n\n  if oldParent ~= '0000' then\n    parentKey = tagKeyBase..oldParent\n    if redis.call('EXISTS', parentKey) == 1 then\n      children = cjson.decode(redis.call('HGET', parentKey, 'children'))\n      remove(children, tid)\n      redis.call('HSET', parentKey, 'children', cjson.encode(children))\n    end\n  end\n\n  -- Delete tag hash\n  redis.call('DEL', tagKey)\n\n  -- Delete tid_mid\n  local tidMidKey = tidMidBaseKey..tid\n  local allMid = redis.call('ZRANGE', tidMidKey, 0, -1)\n  local tagsJSON\n  local tags\n  local newTagsJson\n\n  if #allMid > 0 then \n    for _, mid in pairs(allMid) do\n      tagsJSON = redis.call('HGET', memoBase..mid, 'tags')\n      if tagsJSON then\n        tags = cjson.decode(tagsJSON)\n        for i, tag in pairs(tags) do\n          if tag.tid == tid then\n            table.remove(tags, i)\n          end\n        end\n        -- update memo.tags\n        if #tags == 0 then\n          newTagsJson = '[]'\n        else\n          newTagsJson = cjson.encode(tags)\n        end\n        redis.call('HSET', memoBase..mid, 'tags', newTagsJson)\n        -- add memo changelog\n        memoChangeObject.ts = tagObject.ts\n        memoChangeObject.mid = mid\n        memoChangeObject.tags = newTagsJson\n        redis.call('ZADD', memoChangeLogKey, memoChangeObject.ts, cjson.encode(memoChangeObject))\n      end\n    end\n    redis.call('DEL', tidMidKey)\n    --delete all_tags member here (zrem [user_id]/all_tags tid)\n  end\n\n  -- Add Device, only for 'add' op\n  redis.call('SADD', devicesKey, tagObject.device_id)\n  -- Loggin changes\n  redis.call('ZADD', tagChangeLogKey, tagObject.ts, cjson.encode(tagObject))\nend\n\nfor _, tid in ipairs(tagsNeedDeleted) do\n  deleteOneTag(tid)\nend\n\nreturn {0}";
        return _this.db.run_script(script, 0, tagKeyBase, tagKeyMappingBase, tidMidBaseKey, memoBase, changeLogKey, memoChangeLogKey, tag.old_ts, JSON.stringify(memoChangeObject), JSON.stringify(deleteObject), devicesKey, function(err, res) {
          var result;
          if (err != null) {
            return next(err);
          }
          switch (res[0]) {
            case 0:
              result = {
                tid: tag.tid,
                ts: new_ts
              };
              break;
            case 1:
              result = Utils.redisArrayToObject(res[1]);
              break;
            case -3:
              result = {
                tid: tag.tid
              };
          }
          result._order = tag._order;
          result.op = tag.op;
          result.status = res[0];
          return next(null, result);
        });
      };
      try {
        error = Checker.collectErrors('op', tag, ParamRules, null);
      } catch (e) {
        return cb(e);
      }
      if (error != null) {
        finalResponse.push(errorResponse(-1, error));
        return cb();
      }
      try {
        switch (tag.op) {
          case 1:
            error = addArgsCheck();
            break;
          case 2:
            error = updateArgsCheck();
            break;
          case 3:
            error = deleteArgsCheck();
        }
      } catch (e) {
        return cb(e);
      }
      if (error != null) {
        finalResponse.push(errorResponse(-1, error));
        return cb();
      }
      savingCallback = function(err, res) {
        if (err != null) {
          return cb(err);
        }
        finalResponse.push(res);
        return cb();
      };
      switch (tag.op) {
        case 1:
          return add(savingCallback);
        case 2:
          return upd(savingCallback);
        case 3:
          return del(savingCallback);
      }
    };
    data = request.data;
    error = Checker.checkRulesWithError("data", data, {
      'ARRAY': true
    }, error);
    if (error != null) {
      res = {
        status: -1,
        error: error
      };
      return next(null, res);
    }
    finalResponse = [];
    for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
      value = data[index];
      data[index]._order = index;
    }
    return Async.forEach(data, processItem, function(err) {
      var _j, _len1;
      if (err != null) {
        return next(err);
      }
      finalResponse.sort(function(m1, m2) {
        return m1._order - m2._order;
      });
      for (_j = 0, _len1 = finalResponse.length; _j < _len1; _j++) {
        res = finalResponse[_j];
        delete res._order;
      }
      return next(null, finalResponse);
    });
  };

  return _TagModel;

})();

/*
# Modulereturn Exports
*/


tagModel = coreClass.get();

module.exports.upload = function(request, next) {
  return tagModel.upload(request, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};
