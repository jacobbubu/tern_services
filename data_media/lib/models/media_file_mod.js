// Generated by CoffeeScript 1.3.3
var Assert, BrokersHelper, Chunk, Client, Config, GStream, GridStore, Log, Mongodb, RedisClient, Server, callAfterDBConnected, coreClass, deleteChunks, mediaFile, _MediaFile,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Mongodb = require('mongodb').Db;

Server = require('mongodb').Server;

GridStore = require('mongodb').GridStore;

Chunk = require('mongodb').Chunk;

Client = require("redis").createClient();

Assert = require('assert');

BrokersHelper = require('tern.central_config').BrokersHelper;

Log = require('tern.logger');

RedisClient = require('tern.database');

GStream = require('./gridstore_stream');

Config = BrokersHelper.getConfig('databases/mediaMongo').value;

deleteChunks = function(self, callback) {
  if (self.fileId !== null) {
    return self.chunkCollection(function(err, collection) {
      if (err != null) {
        return callback(err, false);
      }
      return collection.remove({
        'files_id': self.fileId
      }, {
        safe: true
      }, function(err, result) {
        if (err != null) {
          return callback(err, false);
        }
        return callback(null, true);
      });
    });
  } else {
    return callback(null, true);
  }
};

GridStore.unlinkReturnCount = function(db, name, options, callback) {
  var args, gStore, self;
  self = this;
  args = Array.prototype.slice.call(arguments, 2);
  callback = args.pop();
  options = args.length > 0 ? args.shift() : null;
  gStore = new GridStore(db, name, "w", options);
  return gStore.open(function(err, gridStore) {
    if (err != null) {
      return callback(err);
    }
    return deleteChunks(gridStore, function(err, result) {
      if (err != null) {
        return callback(err);
      }
      return gridStore.collection(function(err, collection) {
        if (err != null) {
          return callback(err);
        }
        return collection.remove({
          '_id': gridStore.fileId
        }, {
          safe: true
        }, function(err, numberOfRemovedMedia) {
          return callback(err, numberOfRemovedMedia);
        });
      });
    });
  });
};

coreClass = (function() {
  var _instance;

  function coreClass() {}

  _instance = void 0;

  coreClass.get = function() {
    return _instance != null ? _instance : _instance = new _MediaFile;
  };

  return coreClass;

})();

_MediaFile = (function() {

  function _MediaFile() {
    this.createReadStream = __bind(this.createReadStream, this);

    this.closeUpload = __bind(this.closeUpload, this);

    this.rangeUpload = __bind(this.rangeUpload, this);

    this.startUpload = __bind(this.startUpload, this);

    this.unlink = __bind(this.unlink, this);

    this.stat = __bind(this.stat, this);
    this.db = new Mongodb('TernMedia', new Server(Config.host, Config.port));
    this.redisLock = RedisClient.getDB('RedisLockDB');
    this.lock = require('redis-lock')(this.redisLock);
  }

  _MediaFile.prototype.stat = function(media_id, next) {
    var _this = this;
    return this.lock(media_id, function(lockDone) {
      return GridStore.exist(_this.db, media_id, function(err, existence) {
        var mediaFile;
        if (err != null) {
          lockDone(function() {
            return next(err);
          });
        }
        if (!existence) {
          return lockDone(function() {
            var stats;
            stats = {
              currentLength: 0,
              contentType: 'unknown',
              chunkSize: NaN,
              ctime: 0,
              atime: 0,
              mtime: 0,
              instanceLength: NaN,
              instanceMD5: ''
            };
            return next(null, stats);
          });
        } else {
          mediaFile = new GridStore(_this.db, media_id, 'r');
          return mediaFile.open(function(err, mediaFile) {
            return lockDone(function() {
              var stats;
              if (err != null) {
                return next(err);
              }
              stats = {
                currentLength: mediaFile.length,
                contentType: mediaFile.contentType,
                chunkSize: mediaFile.chunkSize,
                ctime: mediaFile.metadata.createDate,
                atime: mediaFile.metadata.accessDate,
                mtime: mediaFile.metadata.modifyDate,
                instanceLength: mediaFile.metadata.instanceLength,
                instanceMD5: mediaFile.metadata.instanceMD5
              };
              return next(null, stats);
            });
          });
        }
      });
    });
  };

  _MediaFile.prototype.unlink = function(media_id, next) {
    var _this = this;
    return this.lock(media_id, function(lockDone) {
      return GridStore.unlinkReturnCount(_this.db, media_id, function(err, numberOfRemovedDocs) {
        return lockDone(function() {
          return next(err, numberOfRemovedDocs);
        });
      });
    });
  };

  _MediaFile.prototype.startUpload = function(fileInfo, next) {
    var _this = this;
    return this.lock(fileInfo.media_id, function(lockDone) {
      return GridStore.exist(_this.db, fileInfo.media_id, function(err, existence) {
        var dbChunkSize, gridStore, instanceLength, mode, now, options;
        if (err != null) {
          lockDone(function() {
            return next(err);
          });
        }
        now = +(new Date);
        if (!existence) {
          mode = 'w';
          options = {
            'content_type': fileInfo.contentType,
            metadata: {
              instanceLength: fileInfo.instanceLength,
              instanceMD5: fileInfo.instanceMD5,
              createDate: now,
              accessDate: now,
              modifyDate: now
            }
          };
          instanceLength = fileInfo.instanceLength;
          if (instanceLength > 16 * 1024 * 1024) {
            dbChunkSize = 2 * 1024 * 1024;
          } else if (instanceLength > 4 * 1024 * 1024) {
            dbChunkSize = 1024 * 1024;
          } else if (instanceLength > 1024 * 1024) {
            dbChunkSize = 512 * 1024;
          } else if (instanceLength > 256 * 1024) {
            dbChunkSize = 256 * 1024;
          } else {
            dbChunkSize = instanceLength;
          }
          options['chunk_size'] = dbChunkSize;
        } else {
          mode = 'w+';
          options = null;
        }
        gridStore = new GridStore(_this.db, fileInfo.media_id, mode, options);
        return gridStore.open(function(err, gridStore) {
          return lockDone(function() {
            return next(err, gridStore);
          });
        });
      });
    });
  };

  _MediaFile.prototype.rangeUpload = function(fileInfo, gridStore, data, next) {
    var _this = this;
    return this.lock(fileInfo.media_id, function(lockDone) {
      return gridStore.write(data, false, function(err, gridStore) {
        return lockDone(function() {
          if (err != null) {
            return next(err);
          }
          if (gridStore.position >= fileInfo.instanceLength) {
            return gridStore.close(function(err, uploadResult) {
              return next(err, uploadResult);
            });
          } else {
            return next(null, null);
          }
        });
      });
    });
  };

  _MediaFile.prototype.closeUpload = function(fileInfo, gridStore, next) {
    var _this = this;
    return this.lock(fileInfo.media_id, function(lockDone) {
      return gridStore.close(function(err, uploadResult) {
        return lockDone(function() {
          return next(err, uploadResult);
        });
      });
    });
  };

  _MediaFile.prototype.createReadStream = function(media_id, options, next) {
    var _this = this;
    return this.lock(media_id, function(lockDone) {
      var gridStore;
      if (arguments.count === 2) {
        next = options;
        options = null;
      }
      gridStore = new GridStore(_this.db, media_id, 'r');
      return gridStore.open(function(err, mediaFile) {
        return lockDone(function() {
          var instanceLength, stream;
          if (err != null) {
            return next(err);
          }
          instanceLength = mediaFile.metadata.instanceLength;
          if ((instanceLength != null) && instanceLength === mediaFile.length) {
            stream = new GStream(mediaFile, options);
          } else {
            stream = null;
          }
          return next(null, stream);
        });
      });
    });
  };

  return _MediaFile;

})();

/*
# Modulereturn Exports
*/


mediaFile = coreClass.get();

callAfterDBConnected = function(func, params) {
  var next;
  next = params.pop();
  params.push(function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
  if (mediaFile.db.state === 'disconnected') {
    return mediaFile.db.open(function(err, db) {
      if (err != null) {
        return next(err);
      }
      return func.apply(module, params);
    });
  } else {
    return func.apply(module, params);
  }
};

/*
module.exports.stat = (media_id, next) ->
  if mediaFile.db.state is 'disconnected'
    mediaFile.db.open (err, db) ->
      return next err if err?

      mediaFile.stat media_id, (err, stats) ->
        return next err, stats if next?
  else
    mediaFile.stat media_id, (err, stats) =>
      return next err, stats if next?
*/


module.exports.stat = function(media_id, next) {
  return callAfterDBConnected(mediaFile.stat, [media_id, next]);
};

module.exports.unlink = function(media_id, next) {
  return callAfterDBConnected(mediaFile.unlink, [media_id, next]);
};

module.exports.createReadStream = function(media_id, options, next) {
  return callAfterDBConnected(mediaFile.createReadStream, [media_id, options, next]);
};

module.exports.startUpload = function(fileInfo, next) {
  return callAfterDBConnected(mediaFile.startUpload, [fileInfo, next]);
};

module.exports.rangeUpload = function(fileInfo, gridStore, data, next) {
  return callAfterDBConnected(mediaFile.rangeUpload, [fileInfo, gridStore, data, next]);
};

module.exports.closeUpload = function(fileInfo, mediaStore, next) {
  return callAfterDBConnected(mediaFile.closeUpload, [fileInfo, mediaStore, next]);
};
