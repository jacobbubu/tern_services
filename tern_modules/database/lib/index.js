// Generated by CoffeeScript 1.3.3
/*
# Helper for accessing redis database
#
*/

var BrokersHelper, Databases, Log, Perf, PerfPrefix, Redis, getDbConfig, isEmpty,
  __slice = [].slice;

Redis = require("redis");

Perf = require("tern.perf_counter");

Log = require("tern.logger");

BrokersHelper = require('tern.central_config').BrokersHelper;

PerfPrefix = "";

/*
# return true when value in null, undefined or empty string
*/


isEmpty = function(value) {
  var type;
  if (!(value != null)) {
    return true;
  }
  type = typeof value;
  switch (type) {
    case 'string':
      return value.trim().length === 0;
    default:
      return false;
  }
};

/*
# Add run_script extension
*/


Redis.RedisClient.prototype.run_script = function() {
  var args, db, next, script, sha1, _i;
  script = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), next = arguments[_i++];
  if (isEmpty(script)) {
    throw new TypeError("script required.");
  }
  if (args.length > 0 && (args[0] instanceof Array)) {
    args = args[0];
  }
  db = this;
  sha1 = db._scripts[script];
  if (sha1 != null) {
    return db.evalsha(sha1, args, function(err, res) {
      if (err != null) {
        if (err === "NOSCRIPT") {
          return db.script_load(script, function(err, res) {
            if (err != null) {
              return next(err, null);
            } else {
              return db.evalsha(sha1, args, function(err, res) {
                return next(err, res);
              });
            }
          });
        } else {
          return next(err, null);
        }
      } else {
        return next(null, res);
      }
    });
  } else {
    return db.script_load(script, function(err, sha1) {
      if (err != null) {
        return next(err, null);
      } else {
        db._scripts[script] = sha1;
        return db.evalsha(sha1, args, function(err, res) {
          return next(err, res);
        });
      }
    });
  }
};

/*
# Add EVALSHA extension
*/


Redis.RedisClient.prototype.evalsha = function() {
  var args, db, next, sha1, _i;
  sha1 = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), next = arguments[_i++];
  if (isEmpty(sha1)) {
    throw new TypeError("sha1 required.");
  }
  if (args.length > 0 && (args[0] instanceof Array)) {
    args = args[0];
  }
  db = this;
  args.unshift(sha1);
  return db.send_command("EVALSHA", args, function(err, res) {
    if (err != null) {
      if (/error/.test(err)) {
        err = "NOSCRIPT";
      }
      return next(err, null);
    } else {
      return next(null, res);
    }
  });
};

/*
# Add SCRIPT LOAD load extension
*/


Redis.RedisClient.prototype.script_load = function(script, next) {
  var args, db;
  if (isEmpty(script)) {
    throw new TypeError("script required.");
  }
  db = this;
  args = ["LOAD", script];
  return db.send_command("SCRIPT", args, function(err, res) {
    return next(err, res);
  });
};

/*
# Add DEL_KEYS extension
#   support redis KEYS pattern
*/


Redis.RedisClient.prototype.del_keys = function(pattern, next) {
  var db, script;
  if (isEmpty(pattern)) {
    throw new TypeError("pattern required.");
  }
  db = this;
  script = "local keys = redis.call('keys',ARGV[1]);\nfor i,v in ipairs(keys) do \n  redis.call('del',v) \nend;\nreturn #keys";
  return db.run_script(script, 0, pattern, function(err, res) {
    return next(err, res);
  });
};

getDbConfig = function(dbName) {
  var configObj, result;
  configObj = BrokersHelper.getConfig("databases/" + dbName);
  if (configObj != null) {
    return configObj.value;
  } else {
    return result = {
      host: 'localhost',
      port: 6379,
      dbid: 0,
      unixsocket: '/tmp/redis.sock'
    };
  }
};

Databases = (function() {

  function Databases() {}

  Databases.openedDb = {};

  Databases.getClient = function(dbName) {
    var client, config, _ref;
    if (isEmpty(dbName)) {
      throw new TypeError("dbName required.");
    }
    config = getDbConfig(dbName);
    if (config.unixsocket != null) {
      client = Redis.createClient(config.unixsocket);
    } else {
      client = Redis.createClient(config.port, config.host);
    }
    client._dbid = (_ref = config.dbid) != null ? _ref : 0;
    client._name = dbName;
    client._scripts = {};
    if (client._dbid !== 0) {
      client.select(client._dbid, function(err, res) {
        var message;
        if (err != null) {
          message = "" + client._name + " - Select to database('" + client._dbid + "') failed.";
          Log.error(message);
          throw new Error(message);
        }
      });
    }
    client.on("ready", function(err) {
      Perf.increment([PerfPrefix, client._name].join("."));
    });
    client.on("error", function(err) {
      Log.error("" + client._name + " - Error occured: " + err + ".");
    });
    client.on("end", function(err) {
      delete Databases.openedDb[client._name];
      Perf.decrement([PerfPrefix, client._name].join("."));
    });
    return client;
  };

  Databases.add = function(dbName) {
    if (Databases.openedDb[dbName] == null) {
      Databases.openedDb[dbName] = Databases.getClient(dbName);
    }
    return Databases.openedDb[dbName];
  };

  Databases.remove = function(dbName) {
    Databases.openedDb[dbName].end();
    return delete Databases.openedDb[dbName];
  };

  return Databases;

})();

exports.getDB = function(dbName) {
  return Databases.add(dbName);
};
