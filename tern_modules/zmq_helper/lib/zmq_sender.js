// Generated by CoffeeScript 1.3.3
var Err, Utils, ZMQKey, ZMQSender, zmq,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

zmq = require('zmq');

Utils = require('tern.utils');

Err = require('tern.exceptions');

ZMQKey = require('./zmq_key');

ZMQSender = (function() {

  function ZMQSender(endpoint, key_iv, identity, defaultTimeout) {
    var _ref;
    this.endpoint = endpoint;
    this.key_iv = key_iv;
    this.identity = identity;
    this.defaultTimeout = defaultTimeout;
    this._clean = __bind(this._clean, this);

    if (this.endpoint == null) {
      throw new Error("Endpoint required.");
    }
    this.key_iv = (_ref = this.key_iv) != null ? _ref : ZMQKey.key_iv;
    if (this.defaultTimeout == null) {
      this.defaultTimeout = 60 * 1000;
    }
    this.socket = zmq.socket('req');
    this.cleanTimer = null;
    this._connect();
  }

  ZMQSender.prototype._clean = function() {
    var k, next, v, _ref, _results;
    _ref = this._requests;
    _results = [];
    for (k in _ref) {
      v = _ref[k];
      if (v.expire_at < +(new Date)) {
        next = v.next;
        delete this._requests[k];
        _results.push(next(Err.TimeoutException("Request to '" + this.endpoint + "' is timeout.")));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  ZMQSender.prototype._connect = function() {
    var _this = this;
    if (this.identity != null) {
      this.socket.identity = this.identity;
    }
    this._requests = {};
    this.socket.connect(this.endpoint);
    return this.socket.on('message', function(buffer) {
      var message, messageObj, next, req_ts;
      message = Utils.decryptAndUnlzf(buffer, _this.key_iv);
      messageObj = JSON.parse(message);
      req_ts = messageObj.req_ts;
      if (_this._requests[req_ts] != null) {
        next = _this._requests[req_ts].next;
        delete _this._requests[req_ts];
        return next(null, messageObj);
      }
    });
  };

  /*
    # Send a message to socket
    # Params: 
    #   1st: a message object
    #   2nd: timeout (optional)
    #   3rd: a callback (optional)
  */


  ZMQSender.prototype.send = function() {
    var buffer, message, newTS, next, strMessage, timeout,
      _this = this;
    newTS = Utils.getTimestamp('zmq_sender');
    message = {
      req_ts: newTS,
      request: arguments[0]
    };
    strMessage = JSON.stringify(message);
    if (arguments.length < 3) {
      timeout = this.defaultTimeout;
      next = arguments[1];
    } else {
      timeout = timeout * 1000;
      next = arguments[2];
    }
    buffer = Utils.lzfAndEncrypt(strMessage, this.key_iv);
    if (next != null) {
      this._requests[newTS] = {
        'next': next,
        'expire_at': +(new Date) + timeout
      };
      if (this.cleanTimer == null) {
        this.cleanTimer = setInterval(function() {
          _this._clean();
          if (Object.keys(_this._requests).length === 0) {
            clearInterval(_this.cleanTimer);
            return _this.cleanTimer = null;
          }
        }, 1000);
      }
    }
    return this.socket.send(buffer);
  };

  ZMQSender.prototype.close = function() {
    if (this.socket != null) {
      return this.socket.close();
    }
  };

  return ZMQSender;

})();

module.exports = ZMQSender;
