// Generated by CoffeeScript 1.3.3
/*
# Password Hash Module
*/

var Crypto, Lzf, OLD_TS_BY_CATEGORY, PATH_CHAR, PasswordHash, SIZE_1G, SIZE_1K, SIZE_1M, TAG_SPLIT_CHAR, Zlib, hexToBinaryString,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

PasswordHash = require('password-hash');

/*
# mkdir /p module
*/


exports.mkdirp = require('mkdirp');

Zlib = require('zlib');

Crypto = require('crypto');

Lzf = require('tern.lzf');

/*
# Array Helpers
*/


if (!Array.prototype.unique) {
  Array.prototype.unique = function() {
    var key, output, value, _i, _ref, _results;
    output = {};
    for (key = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; key = 0 <= _ref ? ++_i : --_i) {
      output[this[key]] = this[key];
    }
    _results = [];
    for (key in output) {
      value = output[key];
      _results.push(value);
    }
    return _results;
  };
}

if (!Array.prototype.merge) {
  Array.prototype.merge = function(other) {
    return Array.prototype.push.apply(this, other);
  };
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(callback) {
    var element, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      element = this[_i];
      if (callback(element)) {
        _results.push(element);
      }
    }
    return _results;
  };
}

/*
# Array Helpers
*/


if (!String.prototype.reverse) {
  String.prototype.reverse = function() {
    return (this.split('')).reverse().join('');
  };
}

if (!String.prototype.shuffle) {
  String.prototype.shuffle = function() {
    return ((this.split('')).sort(function() {
      return 0.5 - Math.random();
    })).join('');
  };
}

PATH_CHAR = '/';

TAG_SPLIT_CHAR = ':';

exports.pathJoin = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return args.join(PATH_CHAR);
};

/*
# Get type description in coffeescript way
*/


exports.type = function(obj) {
  var classToType, myClass, name, _i, _len, _ref;
  if (obj === void 0 || obj === null) {
    return String(obj);
  }
  classToType = new Object;
  _ref = "Boolean Number String Function Array Date RegExp".split(" ");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    name = _ref[_i];
    classToType["[object " + name + "]"] = name.toLowerCase();
  }
  myClass = Object.prototype.toString.call(obj);
  if (myClass in classToType) {
    return classToType[myClass];
  }
  return "object";
};

/*
# Clone object or array
*/


exports.clone = function(obj) {
  var flags, key, newInstance, _ref, _ref1, _ref2, _ref3;
  if (!(obj != null) || typeof obj !== 'object') {
    return obj;
  }
  switch (exports.type(obj)) {
    case 'date':
      return new Date(obj.getTime());
    case 'regexp':
      flags = '' + ((_ref = obj.global) != null ? _ref : {
        'g': ''
      }) + ((_ref1 = obj.ignoreCase) != null ? _ref1 : {
        'i': ''
      }) + ((_ref2 = obj.multiline) != null ? _ref2 : {
        'm': ''
      }) + ((_ref3 = obj.sticky) != null ? _ref3 : {
        'y': ''
      });
      return new RegExp(obj.source, flags);
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    if (!__hasProp.call(obj, key)) continue;
    newInstance[key] = exports.clone(obj[key]);
  }
  return newInstance;
};

/*
# Snapshot a config object
*/


exports.configSnapshot = function(configNode) {
  var flags, k, result, v, _ref, _ref1, _ref2, _ref3;
  result = {};
  for (k in configNode) {
    if (!__hasProp.call(configNode, k)) continue;
    v = configNode[k];
    if (!(v != null) || typeof v !== 'object') {
      result[k] = v;
      continue;
    }
    switch (exports.type(v)) {
      case 'date':
        result[k] = Date(v.getTime());
        continue;
      case 'regexp':
        flags = '' + ((_ref = v.global) != null ? _ref : {
          'g': ''
        }) + ((_ref1 = v.ignoreCase) != null ? _ref1 : {
          'i': ''
        }) + ((_ref2 = v.multiline) != null ? _ref2 : {
          'm': ''
        }) + ((_ref3 = v.sticky) != null ? _ref3 : {
          'y': ''
        });
        result[k] = RegExp(v.source, flags);
        continue;
    }
    result[k] = exports.configSnapshot(v);
  }
  return result;
};

/*
# Passeord Hash
*/


exports.passwordHash = function(password) {
  return PasswordHash.generate(password);
};

exports.verifyPassword = function(password, hashedPassword) {
  return PasswordHash.verify(password, hashedPassword);
};

hexToBinaryString = function(value) {
  return new Buffer(value, "hex").toString("binary");
};

/*
# compress and encrypt
# params
#   data: A string
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A buffer object
*/


exports.compressAndEncrypt = function(data, key_iv, next) {
  return Zlib.deflate(data, function(err, buffer) {
    var cipher, res, result;
    if (err != null) {
      return next(err);
    }
    cipher = Crypto.createCipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
    result = cipher.update(buffer, 'binary', 'binary');
    result += cipher.final('binary');
    res = new Buffer(result, 'binary');
    return next(null, res);
  });
};

/*
# encrypt a string
# params
#   data: A string
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A buffer object
*/


exports.encrypt = function(data, key_iv) {
  var cipher, result;
  cipher = Crypto.createCipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
  result = cipher.update(data, 'utf8', 'binary');
  result += cipher.final('binary');
  return new Buffer(result, 'binary');
};

/*
#  decrypt and unzip
# params
#   buffer: A buffer object
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A string
*/


exports.decryptAndUncompress = function(buffer, key_iv, next) {
  var data, decipher, zippedData;
  data = buffer.toString('binary');
  decipher = Crypto.createDecipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
  zippedData = decipher.update(data, 'binary', 'binary');
  zippedData += decipher.final('binary');
  return Zlib.unzip(new Buffer(zippedData, 'binary'), function(err, res) {
    if (err != null) {
      return next(err);
    }
    return next(null, res.toString());
  });
};

exports.InbandMessageFormat = {
  Normal: 0,
  LZF: 1
};

/*
# compress using lzf and encrypt
# params
#   message: A string
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A buffer object
*/


exports.lzfAndEncrypt = function(message, key_iv) {
  var cipher, head, lzfedBuffer, messageBuffer, originalBuffer, result;
  cipher = Crypto.createCipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
  originalBuffer = new Buffer(message);
  lzfedBuffer = Lzf.compress(originalBuffer);
  head = new Buffer(1);
  if (originalBuffer.length > lzfedBuffer + 1) {
    head.writeUInt8(exports.InbandMessageFormat.LZF, 0);
    messageBuffer = Buffer.concat([head, lzfedBuffer], head.length + lzfedBuffer.length);
  } else {
    head.writeUInt8(exports.InbandMessageFormat.Normal, 0);
    messageBuffer = Buffer.concat([head, originalBuffer], head.length + originalBuffer.length);
  }
  result = cipher.update(messageBuffer.toString('binary'), 'binary', 'binary');
  result += cipher.final('binary');
  return new Buffer(result, 'binary');
};

/*
# decrypt and unlzf
# params
#   buffer: A buffer object
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A string
*/


exports.decryptAndUnlzf = function(buffer, key_iv) {
  var data, decipher, decipheredBuffer, decipheredData, head, messageBuffer;
  data = buffer.toString('binary');
  decipher = Crypto.createDecipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
  decipheredData = decipher.update(data, 'binary', 'binary');
  decipheredData += decipher.final('binary');
  decipheredBuffer = new Buffer(decipheredData, 'binary');
  head = decipheredBuffer.readUInt8(0);
  messageBuffer = decipheredBuffer.slice(1);
  if (head === exports.InbandMessageFormat.LZF) {
    return Lzf.decompress(messageBuffer);
  } else {
    return messageBuffer.toString();
  }
};

/*
# decrypt a string
# params
#   buffer: buffer: A buffer object
#   key_iv: A object includes key and iv ({key: 'xxx', iv: 'xxx'}).
# return
#   A string
*/


exports.decrypt = function(buffer, key_iv) {
  var data, decipher, result;
  data = buffer.toString('binary');
  decipher = Crypto.createDecipheriv("aes-128-cbc", hexToBinaryString(key_iv.key), hexToBinaryString(key_iv.iv));
  result = decipher.update(data, 'binary', 'utf8');
  result += decipher.final('utf8');
  return result;
};

/*
# Datetime
*/


exports.UTCString = function(date) {
  var d, days, hours, minutes, month, seconds, year;
  d = date != null ? date : new Date;
  year = d.getUTCFullYear().toString();
  year = ('000' + year).slice(-4);
  month = (d.getUTCMonth() + 1).toString();
  month = ('0' + month).slice(-2);
  days = d.getUTCDate().toString();
  days = ('0' + days).slice(-2);
  hours = d.getUTCHours().toString();
  hours = ('0' + hours).slice(-2);
  minutes = d.getUTCMinutes().toString();
  minutes = ('0' + minutes).slice(-2);
  seconds = d.getUTCSeconds().toString();
  seconds = ('0' + seconds).slice(-2);
  return year + month + days + 'T' + hours + ':' + minutes + ':' + seconds + 'Z';
};

exports.createString = function(ch, length) {
  return Array(length + 1).join(ch);
};

OLD_TS_BY_CATEGORY = {};

exports.getTimestamp = function(category) {
  var getNewTS, new_ts, old_ts, result, _ref;
  getNewTS = function() {
    var d, ms;
    d = new Date;
    ms = d.getMilliseconds();
    return d.getTime() * 1000 + ms;
  };
  category = category != null ? category : "DEFAULT_TS";
  new_ts = getNewTS();
  old_ts = (_ref = OLD_TS_BY_CATEGORY[category]) != null ? _ref : 0;
  if (new_ts <= old_ts) {
    new_ts = old_ts + 1;
  }
  OLD_TS_BY_CATEGORY[category] = new_ts;
  result = ('0000000000000000' + new_ts.toString()).slice(-16);
  return new_ts.toString();
};

exports.maxTimestamp = '8888888888888888';

exports.redisArrayToObject = function(arr) {
  var i, len, result, _i, _ref;
  result = {};
  len = arr.length;
  for (i = _i = 0, _ref = len - 1; _i <= _ref; i = _i += 2) {
    result[arr[i]] = arr[i + 1];
  }
  return result;
};

exports.splitTagKey = function(tagKey) {
  var a, palceholder, str, tempArr;
  TAG_SPLIT_CHAR = ':';
  palceholder = '^!@wer^';
  str = tagKey.replace("\\" + TAG_SPLIT_CHAR, palceholder);
  tempArr = str.split(TAG_SPLIT_CHAR);
  return (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = tempArr.length; _i < _len; _i++) {
      a = tempArr[_i];
      _results.push(a.replace(palceholder, TAG_SPLIT_CHAR));
    }
    return _results;
  })();
};

exports.keyToTagIdx = function(tagKey) {
  var a, category, tempArr, user_id;
  tempArr = exports.splitTagKey(tagKey);
  user_id = tempArr[0];
  category = tempArr[1];
  return ((function() {
    var _i, _len, _ref, _results;
    _ref = tempArr.slice(2);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      a = _ref[_i];
      _results.push(category + TAG_SPLIT_CHAR + a);
    }
    return _results;
  })()).unique();
};

SIZE_1K = 1024;

SIZE_1M = SIZE_1K * 1024;

SIZE_1G = SIZE_1M * 1024;

exports.byteSizePresent = function(byteSize) {
  if (byteSize >= SIZE_1G) {
    return (byteSize / SIZE_1G).toFixed(2) + 'G';
  }
  if (byteSize >= SIZE_1M) {
    return (byteSize / SIZE_1M).toFixed(2) + 'M';
  }
  if (byteSize >= SIZE_1K) {
    return (byteSize / SIZE_1K).toFixed(2) + 'K';
  }
  return byteSize.toString();
};

exports.md5 = function(buffer, encoding) {
  return Crypto.createHash('md5').update(buffer).digest(encoding || 'base64');
};

exports.base64ToHex = function(base64) {
  return new Buffer(base64, 'base64').toString('hex');
};

exports.hexToBase64 = function(hex) {
  return new Buffer(hex, 'hex').toString('base64');
};
