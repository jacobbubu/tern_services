// Generated by CoffeeScript 1.3.3
var Utils,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Utils = require('tern.utils');

exports.isEmpty = function(value) {
  var type;
  if (!(value != null)) {
    return true;
  }
  type = typeof value;
  switch (type) {
    case 'string':
      return value.trim().length === 0;
    default:
      return false;
  }
};

exports.isLengthIn = function(value, min, max) {
  var len, type, _ref;
  if (min > max) {
    _ref = [max, min], min = _ref[0], max = _ref[1];
  }
  type = typeof value;
  switch (type) {
    case 'string':
      len = value.trim().length;
      return (min <= len && len <= max);
    default:
      throw new TypeError("Unsupported param type '" + type + "'.");
  }
};

exports.isInRangeOf = function(value, min, max) {
  var type, _ref;
  if (min > max) {
    _ref = [max, min], min = _ref[0], max = _ref[1];
  }
  type = typeof value;
  switch (type) {
    case 'number':
      return (min <= value && value <= max);
    default:
      throw new TypeError("Unsupported param type '" + type + "'.");
  }
};

exports.isMatched = function(value, pattern) {
  if ((typeof value) !== 'string') {
    throw new TypeError("Unsupported param type '" + (typeof value) + "'.");
  }
  if (!(pattern instanceof RegExp)) {
    throw new TypeError("Need RegExp for pattern.");
  }
  return pattern.test(value);
};

exports.keysCount = function(value) {
  var type;
  if (!(value != null)) {
    throw new TypeError("'value' required.");
  }
  type = typeof value;
  switch (type) {
    case 'object':
      return Object.keys(value).length;
    default:
      throw new TypeError("Unsupported param type '" + type + "'.");
  }
};

/*
  rules:
    'REQUIRED': true
    'LENGTH':
      min: 1
      max: 24
    'RANGE':
      min: -180
      max: 180
    'PATTERN': /^\d+$/
    'UNSUPPORTED' : ['add', 'update', 'delete']
    'NUMBER':  true          #need number
    'INTEGER': true          #need number
    'STRING':  true          #need string
    'STRING_INTEGER':  true  #signed integer, expressed in string
    'BOOLEAN': true          #need boolean
    'ISODATE': true          #need string in ISODatetime format
    'NAME_INTEGER': true     #a string in the form of 'name:signed integer'
*/


exports.checkRules = function(value, rules) {
  var name, obj, result, rule, v, _i, _len;
  result = [];
  for (name in rules) {
    rule = rules[name];
    if (value == null) {
      if (exports.isEmpty(value)) {
        result.push('REQUIRED');
      }
    } else {
      switch (name) {
        case 'REQUIRED':
          if (exports.isEmpty(value)) {
            result.push('REQUIRED');
          }
          break;
        case 'STRING':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          }
          break;
        case 'NUMBER':
          if (Utils.type(value) !== 'number') {
            result.push('NUMBER');
          }
          break;
        case 'OBJECT':
          if (Utils.type(value) !== 'object') {
            result.push('OBJECT');
          }
          break;
        case 'INTEGER':
          if (Utils.type(value) !== 'number') {
            result.push('INTEGER');
          } else {
            if (Math.floor(value) !== value) {
              result.push('INTEGER');
            }
          }
          break;
        case 'BOOLEAN':
          if (Utils.type(value) !== 'boolean') {
            result.push('BOOLEAN');
          }
          break;
        case 'ARRAY':
          if (Utils.type(value) !== 'array') {
            result.push('ARRAY');
          }
          break;
        case 'LENGTH':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          } else {
            if (!exports.isLengthIn(value, rule.min, rule.max)) {
              result.push("LENGTH:" + rule.min + ":" + rule.max);
            }
          }
          break;
        case 'RANGE':
          if (Utils.type(value) !== 'number') {
            if (rules.INTEGER == null) {
              result.push('NUMBER');
            }
          } else {
            if (!exports.isInRangeOf(value, rule.min, rule.max)) {
              result.push("RANGE:" + rule.min + ":" + rule.max);
            }
          }
          break;
        case 'UNSUPPORTED':
          if (__indexOf.call(rule, value) < 0) {
            result.push('UNSUPPORTED');
          }
          break;
        case 'UNSUPPORTED/i':
          if (Utils.type(value) === 'string') {
            value = value.toLowerCase();
          }
          if (__indexOf.call(rule, value) < 0) {
            result.push('UNSUPPORTED');
          }
          break;
        case 'PATTERN':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          } else {
            if (!exports.isMatched(value, rule)) {
              result.push('PATTERN');
            }
          }
          break;
        case 'STRING_INTEGER':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          } else {
            if (!exports.isMatched(value, /^[+-]?\d{1,18}$/)) {
              result.push('STRING_INTEGER');
            }
          }
          break;
        case 'STRING_INTEGER_WITH_INF':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          } else {
            if (value !== '+inf' && value !== '-inf') {
              if (!exports.isMatched(value, /^[+-]?\d{1,18}$/)) {
                result.push('STRING_INTEGER');
              }
            }
          }
          break;
        case 'ISODATE':
          if (Utils.type(value) !== 'string') {
            result.push('ISODATE');
          } else {
            if (!exports.isMatched(value, /^(\d{4})\D?(0[1-9]|1[0-2])\D?([12]\d|0[1-9]|3[01])([T]([01]\d|2[0-3])[:]([0-5]\d)[:]([0-5]\d)?[\.]?(\d{3})?([zZ])?)$/)) {
              result.push('ISODATE');
            }
          }
          break;
        case 'NAME_INTEGER':
          if (Utils.type(value) !== 'string') {
            result.push('STRING');
          } else {
            if (!exports.isMatched(value, /^([^\s]{1,24}):[+-]?(\d{1,18})$/)) {
              result.push('NAME_INTEGER');
            }
          }
          break;
        case 'TAG_KEY':
          if (Utils.type(value) !== 'string') {
            result.push('TAG_KEY');
          } else {
            if (!((Utils.splitTagKey(value)).length > 1)) {
              result.push('TAG_KEY');
            }
          }
      }
    }
  }
  obj = {};
  for (_i = 0, _len = result.length; _i < _len; _i++) {
    v = result[_i];
    obj[v] = true;
  }
  return result = Object.keys(obj);
};

exports.checkRulesWithError = function(argName, value, rules, error) {
  var res;
  res = exports.checkRules(value, rules);
  if (res.length > 0) {
    if (error == null) {
      error = {};
    }
    error[argName] = res;
  }
  return error;
};

exports.collectErrors = function(argName, paramObj, rules, error) {
  var res, subObjs, value;
  subObjs = argName.split('.');
  switch (subObjs.length) {
    case 1:
      value = paramObj[subObjs[0]];
      break;
    case 2:
      value = paramObj[subObjs[0]][subObjs[1]];
      break;
    case 3:
      value = paramObj[subObjs[0]][subObjs[1]][subObjs[2]];
      break;
    case 4:
      value = paramObj[subObjs[0]][subObjs[1]][subObjs[2]][subObjs[3]];
      break;
    default:
      throw new Error("Too many levels in " + argName + ".");
  }
  res = exports.checkRules(value, rules[argName]);
  if (res.length > 0) {
    if (error == null) {
      error = {};
    }
    error[argName] = res;
  }
  return error;
};
