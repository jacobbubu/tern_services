// Generated by CoffeeScript 1.3.3
var Broker, Config, Utils, clone, findNode, normalizePath, type, zmq,
  __hasProp = {}.hasOwnProperty,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

zmq = require('zmq');

Config = require('./config');

Utils = require('./utils');

type = function(obj) {
  var classToType, myClass, name, _i, _len, _ref;
  if (obj === void 0 || obj === null) {
    return String(obj);
  }
  classToType = new Object;
  _ref = "Boolean Number String Function Array Date RegExp".split(" ");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    name = _ref[_i];
    classToType["[object " + name + "]"] = name.toLowerCase();
  }
  myClass = Object.prototype.toString.call(obj);
  if (myClass in classToType) {
    return classToType[myClass];
  }
  return "object";
};

clone = function(obj) {
  var flags, key, newInstance, _ref, _ref1, _ref2, _ref3;
  if (!(obj != null) || typeof obj !== 'object') {
    return obj;
  }
  switch (type(obj)) {
    case 'date':
      return new Date(obj.getTime());
    case 'regexp':
      flags = '' + ((_ref = obj.global) != null ? _ref : {
        'g': ''
      }) + ((_ref1 = obj.ignoreCase) != null ? _ref1 : {
        'i': ''
      }) + ((_ref2 = obj.multiline) != null ? _ref2 : {
        'm': ''
      }) + ((_ref3 = obj.sticky) != null ? _ref3 : {
        'y': ''
      });
      return new RegExp(obj.source, flags);
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    if (!__hasProp.call(obj, key)) continue;
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

normalizePath = function(path) {
  var arr, prop, properties;
  properties = path.split('/');
  arr = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = properties.length; _i < _len; _i++) {
      prop = properties[_i];
      if (prop.length > 0) {
        _results.push(prop);
      }
    }
    return _results;
  })();
  return arr.join('/');
};

findNode = function(obj, path) {
  var node, prop, properties, _i, _len;
  properties = path.split('/');
  node = obj;
  for (_i = 0, _len = properties.length; _i < _len; _i++) {
    prop = properties[_i];
    if (prop.length > 0) {
      node = node[prop];
      if (typeof node === 'undefined') {
        throw new Error("Invalid path('" + path + "') in the object");
      }
    }
  }
  return node;
};

Broker = (function() {

  function Broker(options) {
    this.options = options != null ? options : {};
    this.init = __bind(this.init, this);

    this._waitForInit = __bind(this._waitForInit, this);

    this._checkAllConfigs = __bind(this._checkAllConfigs, this);

    this._subResponse = __bind(this._subResponse, this);

    this._reqResponse = __bind(this._reqResponse, this);

    this.allConfigs = {};
    this.centralConfigObj = null;
    this.initCallback = null;
    this._connect();
  }

  Broker.prototype._connect = function() {
    this.requester = zmq.socket("req");
    this.requester.on("message", this._reqResponse);
    this.requester.connect(this.options.requester || "ipc:///tmp/configServer-req");
    this.subscriber = zmq.socket("sub");
    this.subscriber.on("message", this._subResponse);
    this.subscriber.connect(this.options.subscriber || "ipc:///tmp/configServer-sub");
    return this.subscriber.subscribe('config');
  };

  Broker.prototype._reqResponse = function(payload) {
    var message;
    message = payload.toString();
    try {
      return this.centralConfigObj = JSON.parse(message);
    } catch (err) {
      console.error('Bad config data returned by server: #{message}');
      throw err;
    }
  };

  Broker.prototype._subResponse = function(payload) {
    var newConfigObj, pos, temp;
    temp = payload.toString();
    pos = temp.indexOf(' ');
    if (pos === -1) {
      return console.error("Bad config data published by server: " + temp);
    } else {
      try {
        newConfigObj = JSON.parse(temp.slice(pos));
      } catch (err) {
        console.error("Bad config data published by server: " + temp);
      }
      this._checkAllConfigs(newConfigObj);
      return this.centralConfigObj = newConfigObj;
    }
  };

  Broker.prototype._checkAllConfigs = function(newConfigObj) {
    var config, newConfigNode, oldConfigNode, path, _ref, _results;
    _ref = this.allConfigs;
    _results = [];
    for (path in _ref) {
      config = _ref[path];
      try {
        newConfigNode = findNode(newConfigObj, path);
      } catch (err) {
        console.error("Invalid config path(" + path + ") in new configuration");
        continue;
      }
      oldConfigNode = findNode(this.centralConfigObj, path);
      if (!Utils.deepEquals(newConfigNode, oldConfigNode)) {
        if (config.listeners("changed").length !== 0) {
          _results.push(config.emit('changed', oldConfigNode, newConfigNode));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Broker.prototype._fillConfig = function(config, path) {
    var configNode;
    configNode = findNode(this.centralConfigObj, path);
    return config.value = configNode;
  };

  Broker.prototype._waitForInit = function() {
    if (this.centralConfigObj != null) {
      return (this.initCallback != null) && this.initCallback(null, this.centralConfigObj);
    } else {
      return process.nextTick(this._waitForInit);
    }
  };

  Broker.prototype.init = function(next) {
    this.initCallback = next;
    if (this.centralConfigObj == null) {
      this.requester.send('getConfig');
      return process.nextTick(this._waitForInit);
    } else {
      return (next != null) && next(null, this.centralConfigObj);
    }
  };

  Broker.prototype.getConfig = function(path) {
    var config;
    if (path == null) {
      new TypeError('Config path required.');
    }
    if (this.centralConfigObj == null) {
      throw new Error('should call init() first');
    }
    path = normalizePath(path);
    config = this.allConfigs[path];
    if (config == null) {
      config = new Config(path);
      this._fillConfig(config, path);
      this.allConfigs[path] = config;
    }
    return config;
  };

  return Broker;

})();

module.exports = Broker;
