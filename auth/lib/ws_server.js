// Generated by CoffeeScript 1.3.3
var App, AuthFacet, Clients, Domain, Log, Perf, Utils, WSServer, http, locale, supportedLocale;

App = require('express')();

Log = require('tern.logger');

Perf = require('tern.perf_counter');

Utils = require('tern.utils');

http = require('http');

locale = require('locale');

supportedLocale = new locale.Locales(["en"]);

WSServer = (require('websocket')).server;

Clients = require('./models/client_mod');

AuthFacet = require('./wsfacets/auth_facet');

Domain = require('domain');

module.exports.start = function(argv) {
  var serverDomain;
  serverDomain = Domain.create();
  serverDomain.on('error', function(err) {
    return Log.error('Uncaught error on Auth. WS Server: ', err.toString());
  });
  return serverDomain.run(function() {
    var host, httpServer, wsServer;
    httpServer = http.createServer(App);
    App.get('/', function(req, res, next) {
      res.type('text/txt');
      return res.send(require('tern.logo').Auth('0.1'), 200);
    });
    wsServer = new WSServer({
      httpServer: httpServer,
      autoAcceptConnections: false
    });
    host = argv.host === '*' ? null : argv.host;
    httpServer.listen(argv.port, host, function() {
      return Log.notice("Auth. Web Socket Server is listening on ws://" + argv.host + ":" + argv.port);
    });
    return wsServer.on('request', function(request) {
      var acceptLang, authMethod, authorization, client_id, client_secret, compressMethod, contentLang, idLabel, locales, reject, secretLabel, _ref, _ref1;
      reject = function(request, reasonCode, description, internalMessage) {
        try {
          request.reject(reasonCode, description);
        } catch (err) {
          Log.warning('Error sending reject:', err.toString());
        }
        description = internalMessage != null ? internalMessage : description;
        return Log.warning("Connection request rejected by the reason('" + reasonCode + ": " + description + "').");
      };
      if (!/^\/1\/websocket/i.test(request.httpRequest.url)) {
        return reject(request, 404);
      }
      acceptLang = request.httpRequest.headers["accept-language"];
      if (acceptLang != null) {
        locales = new locale.Locales(acceptLang);
        contentLang = locales.best(supportedLocale).toString();
      }
      compressMethod = (_ref = request.httpRequest.headers['x-compress-method']) != null ? _ref : '';
      compressMethod = compressMethod.toLowerCase();
      if (compressMethod !== '' && compressMethod !== 'lzf') {
        return reject(request, 400, "Unsupported X_Compress_Method('" + compressMethod + "').");
      }
      authorization = request.httpRequest.headers.authorization;
      if (authorization == null) {
        return reject(request, 401, "Authorization required.");
      }
      _ref1 = authorization.match(/[a-z0-9\-_]+/gi), authMethod = _ref1[0], idLabel = _ref1[1], client_id = _ref1[2], secretLabel = _ref1[3], client_secret = _ref1[4];
      if (authMethod !== 'Client') {
        return reject(request, 401, "Unsupported authorization method '" + authMethod + "'.");
      }
      if (!((client_id != null) && (client_secret != null))) {
        return reject(request, 401, "Credential required.");
      }
      return Clients.authenticate(client_id, client_secret, function(err, res) {
        var connection;
        if (err != null) {
          return reject(request, 500, 'Internal Error', err);
        }
        if (!res) {
          return reject(request, 401, 'Authentication failed.');
        } else {
          connection = request.accept('auth', request.origin);
          connection._tern = {
            client_id: client_id,
            contentLang: contentLang != null ? contentLang : void 0,
            compressMethod: compressMethod
          };
          connection.on('message', function(message) {
            return AuthFacet.processMessage(connection, message, function(err) {
              if (err != null) {
                try {
                  if (err.reasonCode != null) {
                    connection.drop(err.reasonCode, err.toString());
                    return Log.error("Drop: " + err.reasonCode + ", " + err.internalMessage);
                  } else {
                    connection.drop(1011, "Internal error");
                    return Log.error("Drop: 1011, " + (err.toString()));
                  }
                } catch (e) {
                  return Log.error("Error sending:", e.toString());
                }
              }
            });
          });
          return connection.on('close', function(reasonCode, description) {});
        }
      });
    });
  });
};
