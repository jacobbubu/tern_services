// Generated by CoffeeScript 1.3.3
var AccessTokenTableKey, Async, CODE_LENGTH, Cache, Checker, DB, Err, Log, Perf, RefreshTokenTableKey, Serializer, UserClientAccessTokenTableKey, UserClientRefreshTokenTableKey, Utils, ZMQStatusCodes, coreClass, tokenModel, _TokenModel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Async = require("async");

Serializer = require('serializer');

Log = require('tern.logger');

Perf = require('tern.perf_counter');

Utils = require('tern.utils');

DB = require('tern.database');

Checker = require('tern.param_checker');

Err = require('tern.exceptions');

Cache = require('tern.cache');

ZMQStatusCodes = require('tern.zmq_helper').zmq_status_codes;

/*
# Consts
*/


CODE_LENGTH = 128;

/*
# Redis Database
# Access Token table: (for authentication)
#   type: HASH
#   key:  access_tokens/__token__
#     user_id: xxxx
#     scope: "s1 s2 s3"
# 
# user/client/access_token table: (for revoke)
#   type: String
#     __user_id__/__client_id__/access_token : token key
#
# Refresh Token table: (for authentication)
#   type: HASH
#   key:  refresh_tokens/__token__
#     scope: "s1 s2 s3"
# 
# user/client/refresh_token table: (for revoke)
#   type: String
#     __user_id__/__client_id__/refresh_token : token key
*/


AccessTokenTableKey = function(token) {
  return ['access_tokens', token].join('/');
};

UserClientAccessTokenTableKey = function(user_id, client_id) {
  return [user_id, client_id, 'access_token'].join('/');
};

RefreshTokenTableKey = function(token) {
  return ['refresh_tokens', token].join('/');
};

UserClientRefreshTokenTableKey = function(user_id, client_id) {
  return [user_id, client_id, 'refresh_token'].join('/');
};

coreClass = (function() {
  var _instance;

  function coreClass() {}

  _instance = void 0;

  coreClass.get = function() {
    return _instance != null ? _instance : _instance = new _TokenModel;
  };

  return coreClass;

})();

/*
# Class Definition
*/


_TokenModel = (function() {

  function _TokenModel() {
    this.tokenAuth = __bind(this.tokenAuth, this);

    this.refresh = __bind(this.refresh, this);

    this["new"] = __bind(this["new"], this);
    this.db = DB.getDB('accountDB');
  }

  /*
    # methdos
  */


  _TokenModel.prototype["new"] = function(user_id, client_id, scope, data_zone, ttl, next) {
    var finalResult, fn, goAhead,
      _this = this;
    goAhead = false;
    finalResult = null;
    fn = function(next) {
      var accessToken, accessTokenKey, expires_at, refreshToken, refreshTokenKey, script, userClientAccessTokenKey, userClientRefreshTokenKey;
      try {
        accessToken = Serializer.randomString(CODE_LENGTH);
        refreshToken = Serializer.randomString(CODE_LENGTH);
        accessTokenKey = AccessTokenTableKey(accessToken);
        userClientAccessTokenKey = UserClientAccessTokenTableKey(user_id, client_id);
        refreshTokenKey = RefreshTokenTableKey(refreshToken);
        userClientRefreshTokenKey = UserClientRefreshTokenTableKey(user_id, client_id);
        expires_at = Math.floor((new Date) / 1000) + parseInt(ttl);
      } catch (e) {
        next(e);
      }
      script = "        \nlocal accessTokenKey            = KEYS[1]\nlocal userClientAccessTokenKey  = KEYS[2]\nlocal refreshTokenKey           = KEYS[3]\nlocal userClientRefreshTokenKey = KEYS[4]\nlocal user_id                   = ARGV[1]\nlocal client_id                 = ARGV[2]\nlocal scope                     = ARGV[3]\nlocal data_zone                 = ARGV[4]\nlocal expires_at                = ARGV[5]\n\nlocal exist = redis.call('EXISTS', accessTokenKey)\nif exist == 1 then\n  return 1\nend\nexist = redis.call('EXISTS', refreshTokenKey)\nif exist == 1 then\n  return 1\nend\nlocal oldKey = redis.call('GETSET', userClientAccessTokenKey, accessTokenKey)\nif oldKey then\n  redis.call('DEL', oldKey)  \nend\noldKey = redis.call('GETSET', userClientRefreshTokenKey, refreshTokenKey)\nif oldKey then\n  redis.call('DEL', oldKey)  \nend\nredis.call('HMSET', accessTokenKey, 'user_id', user_id, 'client_id', client_id, 'data_zone', data_zone, 'expires_at', expires_at, 'scope', scope)\nredis.call('HMSET', refreshTokenKey, 'user_id', user_id, 'client_id', client_id, 'data_zone', data_zone, 'scope', scope)\nredis.call('EXPIREAT', accessTokenKey, expires_at)\nreturn 0";
      return _this.db.run_script(script, 4, accessTokenKey, userClientAccessTokenKey, refreshTokenKey, userClientRefreshTokenKey, user_id, client_id, scope, data_zone, expires_at, function(err, result) {
        if (err != null) {
          return next(err);
        } else {
          switch (result) {
            case 0:
              goAhead = true;
              finalResult = {
                'status': 0,
                'result': {
                  'access_token': accessToken,
                  'refresh_token': refreshToken,
                  'token_type': "bearer",
                  'expires_in': ttl
                }
              };
              return next(null);
            case 1:
              return next(null);
          }
        }
      });
    };
    return Async.whilst(function() {
      return goAhead === false;
    }, fn, function(err) {
      if (err != null) {
        return next(err, null);
      } else {
        return next(null, finalResult);
      }
    });
  };

  _TokenModel.prototype.refresh = function(client_id, refreshToken, ttl, next) {
    var finalResult, fn, goAhead,
      _this = this;
    goAhead = false;
    finalResult = null;
    fn = function(next) {
      var accessToken, accessTokenKey, expires_at, refreshTokenKey, script;
      try {
        accessToken = Serializer.randomString(CODE_LENGTH);
        accessTokenKey = AccessTokenTableKey(accessToken);
        refreshTokenKey = RefreshTokenTableKey(refreshToken);
        expires_at = Math.floor((new Date).getTime() / 1000) + parseInt(ttl);
      } catch (e) {
        next(e);
      }
      script = "local accessTokenKey            = KEYS[1]\nlocal refreshTokenKey           = ARGV[1]\nlocal client_id                 = ARGV[2]\nlocal expires_at                = ARGV[3]\n\nlocal exist = redis.call('EXISTS', accessTokenKey)\nif exist == 1 then\n  return 1\nend\nexist = redis.call('EXISTS', refreshTokenKey)\nif exist == 0 then\n  return -1\nend\nlocal oldClientId = redis.call('HGET', refreshTokenKey, 'client_id')\nif oldClientId ~= client_id then\n  return -1\nend\nlocal user_id   = redis.call('HGET', refreshTokenKey, 'user_id')\nlocal scope     = redis.call('HGET', refreshTokenKey, 'scope')\nlocal data_zone = redis.call('HGET', refreshTokenKey, 'data_zone')\n\nlocal userClientAccessTokenKey  = user_id..\"/\"..client_id..\"/\"..\"access_token\"\n\nlocal oldKey = redis.call('GETSET', userClientAccessTokenKey, accessTokenKey)\nif oldKey then\n  redis.call('DEL', oldKey)  \nend\nredis.call('HMSET', accessTokenKey, 'user_id', user_id, 'client_id', client_id, 'data_zone', data_zone, 'expires_at', expires_at, 'scope', scope)\nredis.call('EXPIREAT', accessTokenKey, expires_at)\nreturn 0        ";
      return _this.db.run_script(script, 1, accessTokenKey, refreshTokenKey, client_id, expires_at, function(err, result) {
        if (err != null) {
          return next(err);
        }
        switch (result) {
          case 0:
            goAhead = true;
            finalResult = {
              'status': 0,
              'result': {
                'access_token': accessToken,
                'refresh_token': refreshToken,
                'token_type': "bearer",
                'expires_in': ttl
              }
            };
            return next(null);
          case 1:
            return next(null);
          case -1:
          case -2:
            goAhead = true;
            finalResult = {
              'status': -3
            };
            return next(null);
        }
      });
    };
    return Async.whilst(function() {
      return goAhead === false;
    }, fn, function(err) {
      if (err != null) {
        return next(err, null);
      } else {
        return next(null, finalResult);
      }
    });
  };

  _TokenModel.prototype.tokenAuth = function(accessToken, next) {
    var accessTokenKey;
    accessTokenKey = AccessTokenTableKey(accessToken);
    return this.db.hgetall(accessTokenKey, function(err, tokenInfo) {
      var response;
      if (err != null) {
        return next(err);
      } else {
        if (tokenInfo != null) {
          response = {
            status: ZMQStatusCodes.OK,
            result: {
              access_token: accessToken,
              user_id: tokenInfo.user_id,
              client_id: tokenInfo.client_id,
              scope: tokenInfo.scope,
              data_zone: tokenInfo.data_zone,
              expires_in: Math.round(+tokenInfo.expires_at - (new Date) / 1000)
            }
          };
          return next(null, response);
        } else {
          response = {
            status: ZMQStatusCodes.NotFound
          };
          return next(null, response);
        }
      }
    });
  };

  return _TokenModel;

})();

/*
# Module Exports
*/


tokenModel = coreClass.get();

module.exports["new"] = function(user_id, client_id, scope, data_zone, ttl, next) {
  return tokenModel["new"](user_id, client_id, scope, data_zone, ttl, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};

module.exports.refresh = function(client_id, refreshToken, ttl, next) {
  return tokenModel.refresh(client_id, refreshToken, ttl, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};

/*
module.exports.getToken = (user_id, client_id, scope, ttl, next) ->
  tokenModel.getToken user_id, client_id, scope, ttl, (err, res) ->
    next err, res if next?
*/


module.exports.tokenAuth = function(accessToken, next) {
  return tokenModel.tokenAuth(accessToken, function(err, res) {
    if (next != null) {
      return next(err, res);
    }
  });
};
